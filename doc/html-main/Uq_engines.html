<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<link rel="stylesheet" href="style.css" type="text/css">
<meta content="text/html; charset=iso-8859-1" http-equiv="Content-Type">
<link rel="Start" href="index.html">
<link rel="previous" href="Uq_resolver.html">
<link rel="next" href="Uq_multiplex.html">
<link rel="Up" href="index.html">
<link title="Index of types" rel=Appendix href="index_types.html">
<link title="Index of extensions" rel=Appendix href="index_extensions.html">
<link title="Index of exceptions" rel=Appendix href="index_exceptions.html">
<link title="Index of values" rel=Appendix href="index_values.html">
<link title="Index of class attributes" rel=Appendix href="index_attributes.html">
<link title="Index of class methods" rel=Appendix href="index_methods.html">
<link title="Index of classes" rel=Appendix href="index_classes.html">
<link title="Index of class types" rel=Appendix href="index_class_types.html">
<link title="Index of modules" rel=Appendix href="index_modules.html">
<link title="Index of module types" rel=Appendix href="index_module_types.html">
<link title="Uq_gtk" rel="Chapter" href="Uq_gtk.html">
<link title="Uq_tcl" rel="Chapter" href="Uq_tcl.html">
<link title="Equeue" rel="Chapter" href="Equeue.html">
<link title="Unixqueue" rel="Chapter" href="Unixqueue.html">
<link title="Unixqueue_pollset" rel="Chapter" href="Unixqueue_pollset.html">
<link title="Unixqueue_select" rel="Chapter" href="Unixqueue_select.html">
<link title="Uq_resolver" rel="Chapter" href="Uq_resolver.html">
<link title="Uq_engines" rel="Chapter" href="Uq_engines.html">
<link title="Uq_multiplex" rel="Chapter" href="Uq_multiplex.html">
<link title="Uq_transfer" rel="Chapter" href="Uq_transfer.html">
<link title="Uq_socks5" rel="Chapter" href="Uq_socks5.html">
<link title="Uq_io" rel="Chapter" href="Uq_io.html">
<link title="Uq_lwt" rel="Chapter" href="Uq_lwt.html">
<link title="Uq_libevent" rel="Chapter" href="Uq_libevent.html">
<link title="Uq_mt" rel="Chapter" href="Uq_mt.html">
<link title="Uq_client" rel="Chapter" href="Uq_client.html">
<link title="Uq_server" rel="Chapter" href="Uq_server.html">
<link title="Uq_datagram" rel="Chapter" href="Uq_datagram.html">
<link title="Uq_engines_compat" rel="Chapter" href="Uq_engines_compat.html">
<link title="Equeue_intro" rel="Chapter" href="Equeue_intro.html">
<link title="Equeue_howto" rel="Chapter" href="Equeue_howto.html">
<link title="Netcamlbox" rel="Chapter" href="Netcamlbox.html">
<link title="Netcgi_apache" rel="Chapter" href="Netcgi_apache.html">
<link title="Netcgi_modtpl" rel="Chapter" href="Netcgi_modtpl.html">
<link title="Netcgi_plex" rel="Chapter" href="Netcgi_plex.html">
<link title="Netcgi_common" rel="Chapter" href="Netcgi_common.html">
<link title="Netcgi" rel="Chapter" href="Netcgi.html">
<link title="Netcgi_ajp" rel="Chapter" href="Netcgi_ajp.html">
<link title="Netcgi_scgi" rel="Chapter" href="Netcgi_scgi.html">
<link title="Netcgi_cgi" rel="Chapter" href="Netcgi_cgi.html">
<link title="Netcgi_fcgi" rel="Chapter" href="Netcgi_fcgi.html">
<link title="Netcgi_dbi" rel="Chapter" href="Netcgi_dbi.html">
<link title="Netcgi1_compat" rel="Chapter" href="Netcgi1_compat.html">
<link title="Netcgi_test" rel="Chapter" href="Netcgi_test.html">
<link title="Netcgi_porting" rel="Chapter" href="Netcgi_porting.html">
<link title="Nethttp_client_conncache" rel="Chapter" href="Nethttp_client_conncache.html">
<link title="Nethttp_client" rel="Chapter" href="Nethttp_client.html">
<link title="Nettelnet_client" rel="Chapter" href="Nettelnet_client.html">
<link title="Netftp_data_endpoint" rel="Chapter" href="Netftp_data_endpoint.html">
<link title="Netftp_client" rel="Chapter" href="Netftp_client.html">
<link title="Nethttp_fs" rel="Chapter" href="Nethttp_fs.html">
<link title="Netftp_fs" rel="Chapter" href="Netftp_fs.html">
<link title="Netsmtp" rel="Chapter" href="Netsmtp.html">
<link title="Netpop" rel="Chapter" href="Netpop.html">
<link title="Netldap" rel="Chapter" href="Netldap.html">
<link title="Netclient_tut" rel="Chapter" href="Netclient_tut.html">
<link title="Netgss_bindings" rel="Chapter" href="Netgss_bindings.html">
<link title="Netgss" rel="Chapter" href="Netgss.html">
<link title="Nethttpd_types" rel="Chapter" href="Nethttpd_types.html">
<link title="Nethttpd_kernel" rel="Chapter" href="Nethttpd_kernel.html">
<link title="Nethttpd_reactor" rel="Chapter" href="Nethttpd_reactor.html">
<link title="Nethttpd_engine" rel="Chapter" href="Nethttpd_engine.html">
<link title="Nethttpd_services" rel="Chapter" href="Nethttpd_services.html">
<link title="Nethttpd_plex" rel="Chapter" href="Nethttpd_plex.html">
<link title="Nethttpd_util" rel="Chapter" href="Nethttpd_util.html">
<link title="Nethttpd_intro" rel="Chapter" href="Nethttpd_intro.html">
<link title="Netmcore" rel="Chapter" href="Netmcore.html">
<link title="Netmcore_camlbox" rel="Chapter" href="Netmcore_camlbox.html">
<link title="Netmcore_mempool" rel="Chapter" href="Netmcore_mempool.html">
<link title="Netmcore_heap" rel="Chapter" href="Netmcore_heap.html">
<link title="Netmcore_ref" rel="Chapter" href="Netmcore_ref.html">
<link title="Netmcore_array" rel="Chapter" href="Netmcore_array.html">
<link title="Netmcore_sem" rel="Chapter" href="Netmcore_sem.html">
<link title="Netmcore_mutex" rel="Chapter" href="Netmcore_mutex.html">
<link title="Netmcore_condition" rel="Chapter" href="Netmcore_condition.html">
<link title="Netmcore_queue" rel="Chapter" href="Netmcore_queue.html">
<link title="Netmcore_buffer" rel="Chapter" href="Netmcore_buffer.html">
<link title="Netmcore_matrix" rel="Chapter" href="Netmcore_matrix.html">
<link title="Netmcore_hashtbl" rel="Chapter" href="Netmcore_hashtbl.html">
<link title="Netmcore_process" rel="Chapter" href="Netmcore_process.html">
<link title="Netmcore_tut" rel="Chapter" href="Netmcore_tut.html">
<link title="Netmcore_basics" rel="Chapter" href="Netmcore_basics.html">
<link title="Netplex_types" rel="Chapter" href="Netplex_types.html">
<link title="Netplex_mp" rel="Chapter" href="Netplex_mp.html">
<link title="Netplex_mt" rel="Chapter" href="Netplex_mt.html">
<link title="Netplex_log" rel="Chapter" href="Netplex_log.html">
<link title="Netplex_controller" rel="Chapter" href="Netplex_controller.html">
<link title="Netplex_container" rel="Chapter" href="Netplex_container.html">
<link title="Netplex_sockserv" rel="Chapter" href="Netplex_sockserv.html">
<link title="Netplex_workload" rel="Chapter" href="Netplex_workload.html">
<link title="Netplex_main" rel="Chapter" href="Netplex_main.html">
<link title="Netplex_config" rel="Chapter" href="Netplex_config.html">
<link title="Netplex_kit" rel="Chapter" href="Netplex_kit.html">
<link title="Rpc_netplex" rel="Chapter" href="Rpc_netplex.html">
<link title="Netplex_cenv" rel="Chapter" href="Netplex_cenv.html">
<link title="Netplex_semaphore" rel="Chapter" href="Netplex_semaphore.html">
<link title="Netplex_sharedvar" rel="Chapter" href="Netplex_sharedvar.html">
<link title="Netplex_mutex" rel="Chapter" href="Netplex_mutex.html">
<link title="Netplex_encap" rel="Chapter" href="Netplex_encap.html">
<link title="Netplex_mbox" rel="Chapter" href="Netplex_mbox.html">
<link title="Netplex_internal" rel="Chapter" href="Netplex_internal.html">
<link title="Netplex_intro" rel="Chapter" href="Netplex_intro.html">
<link title="Netplex_advanced" rel="Chapter" href="Netplex_advanced.html">
<link title="Netplex_admin" rel="Chapter" href="Netplex_admin.html">
<link title="Netshm" rel="Chapter" href="Netshm.html">
<link title="Netshm_data" rel="Chapter" href="Netshm_data.html">
<link title="Netshm_hashtbl" rel="Chapter" href="Netshm_hashtbl.html">
<link title="Netshm_array" rel="Chapter" href="Netshm_array.html">
<link title="Netshm_intro" rel="Chapter" href="Netshm_intro.html">
<link title="Netstring_pcre" rel="Chapter" href="Netstring_pcre.html">
<link title="Netconversion" rel="Chapter" href="Netconversion.html">
<link title="Netchannels" rel="Chapter" href="Netchannels.html">
<link title="Netstream" rel="Chapter" href="Netstream.html">
<link title="Netmime_string" rel="Chapter" href="Netmime_string.html">
<link title="Netmime" rel="Chapter" href="Netmime.html">
<link title="Netsendmail" rel="Chapter" href="Netsendmail.html">
<link title="Neturl" rel="Chapter" href="Neturl.html">
<link title="Netaddress" rel="Chapter" href="Netaddress.html">
<link title="Netbuffer" rel="Chapter" href="Netbuffer.html">
<link title="Netmime_header" rel="Chapter" href="Netmime_header.html">
<link title="Netmime_channels" rel="Chapter" href="Netmime_channels.html">
<link title="Neturl_ldap" rel="Chapter" href="Neturl_ldap.html">
<link title="Netdate" rel="Chapter" href="Netdate.html">
<link title="Netencoding" rel="Chapter" href="Netencoding.html">
<link title="Netulex" rel="Chapter" href="Netulex.html">
<link title="Netaccel" rel="Chapter" href="Netaccel.html">
<link title="Netaccel_link" rel="Chapter" href="Netaccel_link.html">
<link title="Nethtml" rel="Chapter" href="Nethtml.html">
<link title="Netstring_str" rel="Chapter" href="Netstring_str.html">
<link title="Netmappings" rel="Chapter" href="Netmappings.html">
<link title="Netaux" rel="Chapter" href="Netaux.html">
<link title="Nethttp" rel="Chapter" href="Nethttp.html">
<link title="Netpagebuffer" rel="Chapter" href="Netpagebuffer.html">
<link title="Netfs" rel="Chapter" href="Netfs.html">
<link title="Netglob" rel="Chapter" href="Netglob.html">
<link title="Netauth" rel="Chapter" href="Netauth.html">
<link title="Netsockaddr" rel="Chapter" href="Netsockaddr.html">
<link title="Netnumber" rel="Chapter" href="Netnumber.html">
<link title="Netxdr_mstring" rel="Chapter" href="Netxdr_mstring.html">
<link title="Netxdr" rel="Chapter" href="Netxdr.html">
<link title="Netcompression" rel="Chapter" href="Netcompression.html">
<link title="Netunichar" rel="Chapter" href="Netunichar.html">
<link title="Netasn1" rel="Chapter" href="Netasn1.html">
<link title="Netasn1_encode" rel="Chapter" href="Netasn1_encode.html">
<link title="Netoid" rel="Chapter" href="Netoid.html">
<link title="Netstring_tstring" rel="Chapter" href="Netstring_tstring.html">
<link title="Netdn" rel="Chapter" href="Netdn.html">
<link title="Netx509" rel="Chapter" href="Netx509.html">
<link title="Netascii_armor" rel="Chapter" href="Netascii_armor.html">
<link title="Nettls_support" rel="Chapter" href="Nettls_support.html">
<link title="Netmech_scram" rel="Chapter" href="Netmech_scram.html">
<link title="Netmech_scram_gssapi" rel="Chapter" href="Netmech_scram_gssapi.html">
<link title="Netmech_scram_sasl" rel="Chapter" href="Netmech_scram_sasl.html">
<link title="Netmech_scram_http" rel="Chapter" href="Netmech_scram_http.html">
<link title="Netgssapi_support" rel="Chapter" href="Netgssapi_support.html">
<link title="Netgssapi_auth" rel="Chapter" href="Netgssapi_auth.html">
<link title="Netchannels_crypto" rel="Chapter" href="Netchannels_crypto.html">
<link title="Netx509_pubkey" rel="Chapter" href="Netx509_pubkey.html">
<link title="Netx509_pubkey_crypto" rel="Chapter" href="Netx509_pubkey_crypto.html">
<link title="Netsaslprep" rel="Chapter" href="Netsaslprep.html">
<link title="Netmech_plain_sasl" rel="Chapter" href="Netmech_plain_sasl.html">
<link title="Netmech_crammd5_sasl" rel="Chapter" href="Netmech_crammd5_sasl.html">
<link title="Netmech_digest_sasl" rel="Chapter" href="Netmech_digest_sasl.html">
<link title="Netmech_digest_http" rel="Chapter" href="Netmech_digest_http.html">
<link title="Netmech_krb5_sasl" rel="Chapter" href="Netmech_krb5_sasl.html">
<link title="Netmech_gs2_sasl" rel="Chapter" href="Netmech_gs2_sasl.html">
<link title="Netmech_spnego_http" rel="Chapter" href="Netmech_spnego_http.html">
<link title="Netchannels_tut" rel="Chapter" href="Netchannels_tut.html">
<link title="Netmime_tut" rel="Chapter" href="Netmime_tut.html">
<link title="Netsendmail_tut" rel="Chapter" href="Netsendmail_tut.html">
<link title="Netulex_tut" rel="Chapter" href="Netulex_tut.html">
<link title="Neturl_tut" rel="Chapter" href="Neturl_tut.html">
<link title="Netsys" rel="Chapter" href="Netsys.html">
<link title="Netsys_posix" rel="Chapter" href="Netsys_posix.html">
<link title="Netsys_pollset" rel="Chapter" href="Netsys_pollset.html">
<link title="Netlog" rel="Chapter" href="Netlog.html">
<link title="Netexn" rel="Chapter" href="Netexn.html">
<link title="Netsys_win32" rel="Chapter" href="Netsys_win32.html">
<link title="Netsys_pollset_posix" rel="Chapter" href="Netsys_pollset_posix.html">
<link title="Netsys_pollset_win32" rel="Chapter" href="Netsys_pollset_win32.html">
<link title="Netsys_pollset_generic" rel="Chapter" href="Netsys_pollset_generic.html">
<link title="Netsys_signal" rel="Chapter" href="Netsys_signal.html">
<link title="Netsys_oothr" rel="Chapter" href="Netsys_oothr.html">
<link title="Netsys_xdr" rel="Chapter" href="Netsys_xdr.html">
<link title="Netsys_rng" rel="Chapter" href="Netsys_rng.html">
<link title="Netsys_crypto_types" rel="Chapter" href="Netsys_crypto_types.html">
<link title="Netsys_types" rel="Chapter" href="Netsys_types.html">
<link title="Netsys_mem" rel="Chapter" href="Netsys_mem.html">
<link title="Netsys_tmp" rel="Chapter" href="Netsys_tmp.html">
<link title="Netsys_sem" rel="Chapter" href="Netsys_sem.html">
<link title="Netsys_pmanage" rel="Chapter" href="Netsys_pmanage.html">
<link title="Netsys_crypto" rel="Chapter" href="Netsys_crypto.html">
<link title="Netsys_tls" rel="Chapter" href="Netsys_tls.html">
<link title="Netsys_ciphers" rel="Chapter" href="Netsys_ciphers.html">
<link title="Netsys_digests" rel="Chapter" href="Netsys_digests.html">
<link title="Netsys_crypto_modes" rel="Chapter" href="Netsys_crypto_modes.html">
<link title="Netsys_gssapi" rel="Chapter" href="Netsys_gssapi.html">
<link title="Netsys_sasl_types" rel="Chapter" href="Netsys_sasl_types.html">
<link title="Netsys_sasl" rel="Chapter" href="Netsys_sasl.html">
<link title="Netsys_polypipe" rel="Chapter" href="Netsys_polypipe.html">
<link title="Netsys_polysocket" rel="Chapter" href="Netsys_polysocket.html">
<link title="Netsys_global" rel="Chapter" href="Netsys_global.html">
<link title="Nettls_gnutls_bindings" rel="Chapter" href="Nettls_gnutls_bindings.html">
<link title="Nettls_nettle_bindings" rel="Chapter" href="Nettls_nettle_bindings.html">
<link title="Nettls_gnutls" rel="Chapter" href="Nettls_gnutls.html">
<link title="Netunidata" rel="Chapter" href="Netunidata.html">
<link title="Netgzip" rel="Chapter" href="Netgzip.html">
<link title="Rpc_auth_local" rel="Chapter" href="Rpc_auth_local.html">
<link title="Rpc_xti_client" rel="Chapter" href="Rpc_xti_client.html">
<link title="Rpc" rel="Chapter" href="Rpc.html">
<link title="Rpc_program" rel="Chapter" href="Rpc_program.html">
<link title="Rpc_util" rel="Chapter" href="Rpc_util.html">
<link title="Rpc_portmapper_aux" rel="Chapter" href="Rpc_portmapper_aux.html">
<link title="Rpc_packer" rel="Chapter" href="Rpc_packer.html">
<link title="Rpc_transport" rel="Chapter" href="Rpc_transport.html">
<link title="Rpc_client" rel="Chapter" href="Rpc_client.html">
<link title="Rpc_simple_client" rel="Chapter" href="Rpc_simple_client.html">
<link title="Rpc_portmapper_clnt" rel="Chapter" href="Rpc_portmapper_clnt.html">
<link title="Rpc_portmapper" rel="Chapter" href="Rpc_portmapper.html">
<link title="Rpc_server" rel="Chapter" href="Rpc_server.html">
<link title="Rpc_auth_sys" rel="Chapter" href="Rpc_auth_sys.html">
<link title="Rpc_auth_gssapi" rel="Chapter" href="Rpc_auth_gssapi.html">
<link title="Rpc_proxy" rel="Chapter" href="Rpc_proxy.html">
<link title="Rpc_intro" rel="Chapter" href="Rpc_intro.html">
<link title="Rpc_mapping_ref" rel="Chapter" href="Rpc_mapping_ref.html">
<link title="Rpc_intro_gss" rel="Chapter" href="Rpc_intro_gss.html">
<link title="Shell_sys" rel="Chapter" href="Shell_sys.html">
<link title="Shell" rel="Chapter" href="Shell.html">
<link title="Shell_uq" rel="Chapter" href="Shell_uq.html">
<link title="Shell_fs" rel="Chapter" href="Shell_fs.html">
<link title="Shell_intro" rel="Chapter" href="Shell_intro.html">
<link title="Intro" rel="Chapter" href="Intro.html">
<link title="Platform" rel="Chapter" href="Platform.html">
<link title="Foreword" rel="Chapter" href="Foreword.html">
<link title="Ipv6" rel="Chapter" href="Ipv6.html">
<link title="Regexp" rel="Chapter" href="Regexp.html">
<link title="Tls" rel="Chapter" href="Tls.html">
<link title="Crypto" rel="Chapter" href="Crypto.html">
<link title="Authentication" rel="Chapter" href="Authentication.html">
<link title="Credentials" rel="Chapter" href="Credentials.html">
<link title="Gssapi" rel="Chapter" href="Gssapi.html">
<link title="Ocamlnet4" rel="Chapter" href="Ocamlnet4.html">
<link title="Get" rel="Chapter" href="Get.html"><link title="Exceptions" rel="Section" href="#1_Exceptions">
<link title="Engine definition" rel="Section" href="#1_Enginedefinition">
<link title="Engines and callbacks" rel="Section" href="#1_Enginesandcallbacks">
<link title="Combinators" rel="Section" href="#1_Combinators">
<link title="Combinators" rel="Section" href="#1_Combinators">
<link title="Basic I/O engines" rel="Section" href="#1_BasicIOengines">
<link title="Recursion" rel="Section" href="#1_Recursion">
<link title="Recursion" rel="Section" href="#1_Recursion">
<link title="Recursion" rel="Section" href="#1_Recursion">
<link title="More Engines" rel="Section" href="#1_MoreEngines">
<link title="Recursion" rel="Section" href="#1_Recursion">
<link title="More Engines" rel="Section" href="#1_MoreEngines">
<link title="Recursion" rel="Section" href="#1_Recursion">
<link title="More Engines" rel="Section" href="#1_MoreEngines">
<link title="Moved" rel="Section" href="#1_Moved">
<link title="Recursion" rel="Section" href="#1_Recursion">
<link title="More Engines" rel="Section" href="#1_MoreEngines">
<link title="Moved" rel="Section" href="#1_Moved">
<link title="Debugging" rel="Section" href="#1_Debugging">
<link title="More I/O" rel="Subsection" href="#2_MoreIO">
<link title="More I/O" rel="Subsection" href="#2_MoreIO">
<link title="More I/O" rel="Subsection" href="#2_MoreIO">
<link title="More I/O" rel="Subsection" href="#2_MoreIO">
<link title="More I/O" rel="Subsection" href="#2_MoreIO">
<link title="More I/O" rel="Subsection" href="#2_MoreIO">
<link title="More I/O" rel="Subsection" href="#2_MoreIO">
<title>Ocamlnet 4 Reference Manual : Uq_engines</title>
</head>
<body>
<div class="navbar"><a class="pre" href="Uq_resolver.html" title="Uq_resolver">Previous</a>
&nbsp;<a class="up" href="index.html" title="Index">Up</a>
&nbsp;<a class="post" href="Uq_multiplex.html" title="Uq_multiplex">Next</a>
</div>
<h1>Module <a href="type_Uq_engines.html">Uq_engines</a></h1>

<pre><span class="keyword">module</span> Uq_engines: <code class="code">sig</code> <a href="Uq_engines.html">..</a> <code class="code">end</code></pre><div class="info module top">
An <b>engine</b> performs a certain task in an autonomous way. Engines
 are attached to a <a href="Unixqueue.event_system-c.html"><code class="code">Unixqueue.event_system</code></a>, and do their task by
 generating events for resources of the operating system, and 
 by handling such events. Engines are in one of four states: They
 may be still <b>working</b>, they may be <b>done</b>, they may be
 <b>aborted</b>, or they may be in an <b>error</b> state. The three latter
 states a called <b>final states</b>, because they indicate that the
 engine has stopped operation.
<p>

 It is possible to ask an engine to notify another object when it
 changes its state. For simplicity, notification is done by invoking
 a callback function, and not by issuing notification events.
<p>

 Effectively, engines provide a calculus for cooperative microthreading.
 This calculus includes combinators for sequential execution and
 synchronization. Moreover, it is easy to connect it with callback-style
 microthreading - one can arrange callbacks when an engine is done, and
 one can catch callbacks and turn them into engines.<br>
</div>
<hr width="100%">
<br>
<h1 id="1_Exceptions">Exceptions</h1><br>

<pre><span id="EXCEPTIONClosed_channel"><span class="keyword">exception</span> Closed_channel</span></pre>
<div class="info ">
Raised when a method of a closed channel object is called (only channel
 methods count).
<p>

 This exception should be regarded as equivalent to
 <code class="code">Netchannels.Closed_channel</code>, but need not be the same exception.<br>
</div>

<pre><span id="EXCEPTIONBroken_communication"><span class="keyword">exception</span> Broken_communication</span></pre>
<div class="info ">
Some engines indicate this error when they cannot continue because the
 other endpoint of communication signals an error.
<p>

 This exception is not raised, but used as argument of the <code class="code">`Error</code>
 state.<br>
</div>

<pre><span id="EXCEPTIONWatchdog_timeout"><span class="keyword">exception</span> Watchdog_timeout</span></pre>
<div class="info ">
Used by the watchdog engine to indicate a timeout. 
<p>

 This exception is not raised, but used as argument of the <code class="code">`Error</code>
 state.<br>
</div>

<pre><span id="EXCEPTIONTimeout"><span class="keyword">exception</span> Timeout</span></pre>
<div class="info ">
Used by <code class="code">input_engine</code> and <code class="code">output_engine</code> to indicate timeouts<br>
</div>

<pre><span id="EXCEPTIONAddressing_method_not_supported"><span class="keyword">exception</span> Addressing_method_not_supported</span></pre>
<div class="info ">
Raised by <code class="code">client_endpoint_connector</code> and <code class="code">server_endpoint_acceptor</code> to
 indicate that the passed address is not supported by the class.<br>
</div>

<pre><span id="EXCEPTIONCancelled"><span class="keyword">exception</span> Cancelled</span></pre>
<div class="info ">
The callback function of a <code class="code">multiplex_controller</code> is invoked with this
 exception if the operation is cancelled.<br>
</div>
<br>
<h1 id="1_Enginedefinition">Engine definition</h1><br>

<pre><span id="TYPEengine_state"><span class="keyword">type</span> <code class="type">'t</code> engine_state</span> = <code class="type">[ `Aborted | `Done of 't | `Error of exn | `Working of int ]</code> </pre>
<div class="info ">
The type of states with result values of type <code class="code">'t</code>:<ul>
<li><code class="code">`Working n</code>: The engine is working. The number <code class="code">n</code> counts the number
   of events that have been processed.</li>
<li><code class="code">`Done arg</code>: The engine has completed its task without errors. 
   The argument <code class="code">arg</code> is the result value of the engine</li>
<li><code class="code">`Error exn</code>: The engine has aborted because of an error. The
   argument <code class="code">exn</code> describes the error as an exception.</li>
<li><code class="code">`Aborted</code>: The engine has aborted because the <code class="code">abort</code> method
   was called</li>
</ul>
<br>
</div>


<pre><span id="TYPEfinal_state"><span class="keyword">type</span> <code class="type">'t</code> final_state</span> = <code class="type">[ `Aborted | `Done of 't | `Error of exn ]</code> </pre>
<div class="info ">
Same as <code class="code">engine_state</code> without <code class="code">`Working</code>. These are only the final
	states.<br>
</div>


<pre><span id="VALstring_of_state"><span class="keyword">val</span> string_of_state</span> : <code class="type">'a <a href="Uq_engines.html#TYPEengine_state">engine_state</a> -> string</code></pre><div class="info ">
For debug purposes: Returns a string describing the state<br>
</div>

<pre><span id="TYPEengine"><span class="keyword">class type</span> <code class="type">['t]</code> <a href="Uq_engines.engine-c.html">engine</a></span> = <code class="code">object</code> <a href="Uq_engines.engine-c.html">..</a> <code class="code">end</code></pre><div class="info">
This class type defines the interface an engine must support.
</div>

<pre><span name="TYPEdelegate_engine"><span class="keyword">class</span> <code class="type">['t]</code> <a href="Uq_engines.delegate_engine-c.html">delegate_engine</a></span> : <code class="type">'t #<a href="Uq_engines.engine-c.html">engine</a> -> </code><code class="type">['t]</code> <code class="type"><a href="Uq_engines.engine-c.html">engine</a></code></pre><div class="info">
Turns an engine value into a class
</div>
<br>
<h1 id="1_Enginesandcallbacks">Engines and callbacks</h1><br>

<pre><span id="VALwhen_state"><span class="keyword">val</span> when_state</span> : <code class="type">?is_done:('a -> unit) -><br>       ?is_error:(exn -> unit) -><br>       ?is_aborted:(unit -> unit) -><br>       ?is_progressing:(int -> unit) -> 'a #<a href="Uq_engines.engine-c.html">engine</a> -> unit</code></pre><div class="info ">
Watches the state of the argument engine, and arranges that one of
 the functions is called when the corresponding state change is done. 
 Once a final state is reached, the engine is no longer watched.
 Note that <code class="code">when_state</code> only observes future state changes.
<p>

 If one of the functions raises an exception, this exception is
 propagated to the caller of <a href="Unixqueue.html#VALrun"><code class="code">Unixqueue.run</code></a>.
<p>

<br>
</div>
<div class="param_info"><code class="code">is_done</code> : The state transitions to <code class="code">`Done</code>. The argument of
   <code class="code">is_done</code> is the argument of the <code class="code">`Done</code> state.</div>
<div class="param_info"><code class="code">is_error</code> : The state transitions to <code class="code">`Error</code>. The argument of
   <code class="code">is_error</code> is the argument of the <code class="code">`Error</code> state.</div>
<div class="param_info"><code class="code">is_aborted</code> : The state transitions to <code class="code">`Aborted</code>.</div>
<div class="param_info"><code class="code">is_progressing</code> : This function is called when the <code class="code">`Working</code>
   state changes. The int argument is the new <code class="code">`Working</code> arg.</div>

<pre><span name="TYPEsignal_engine"><span class="keyword">class</span> <code class="type">['a]</code> <a href="Uq_engines.signal_engine-c.html">signal_engine</a></span> : <code class="type"><a href="Unixqueue.event_system-c.html">Unixqueue.event_system</a> -> </code><code class="code">object</code> <a href="Uq_engines.signal_engine-c.html">..</a> <code class="code">end</code></pre><div class="info">
<code class="code">let se = new signal_engine esys</code>: The engine <code class="code">se</code> remains in
      <code class="code">`Working 0</code> until the method <code class="code">se # signal x</code> is called.
</div>

<pre><span id="VALsignal_engine"><span class="keyword">val</span> signal_engine</span> : <code class="type"><a href="Unixqueue.event_system-c.html">Unixqueue.event_system</a> -><br>       'a <a href="Uq_engines.engine-c.html">engine</a> * ('a <a href="Uq_engines.html#TYPEfinal_state">final_state</a> -> unit)</code></pre><div class="info ">
<code class="code">let (se, signal) = signal_engine esys</code>: Same as function<br>
</div>
<br>
<h1 id="1_Combinators">Combinators</h1><br>
<br>
<h1 id="1_Combinators">Combinators</h1><br>
<br>
The following combinators serve as the control structures to connect
    primitive engines with each other.<br>

<pre><span name="TYPEmap_engine"><span class="keyword">class</span> <code class="type">[['a, 'b]]</code> <a href="Uq_engines.map_engine-c.html">map_engine</a></span> : <code class="type">map_done:('a -> 'b <a href="Uq_engines.html#TYPEengine_state">engine_state</a>) -> ?map_error:exn -> 'b <a href="Uq_engines.html#TYPEengine_state">engine_state</a> -> ?map_aborted:unit -> 'b <a href="Uq_engines.html#TYPEengine_state">engine_state</a> -> ?propagate_working:bool -> 'a #<a href="Uq_engines.engine-c.html">engine</a> -> </code><code class="type">['b]</code> <code class="type"><a href="Uq_engines.engine-c.html">engine</a></code></pre><div class="info">
The <code class="code">map_engine</code> observes the argument engine, and when the
 state changes to <code class="code">`Done</code>, <code class="code">`Error</code>, or <code class="code">`Aborted</code>, the corresponding
 mapping function is called, and the resulting state becomes the state
 of the mapped engine.
</div>

<pre><span id="VALmap_engine"><span class="keyword">val</span> map_engine</span> : <code class="type">map_done:('a -> 'b <a href="Uq_engines.html#TYPEengine_state">engine_state</a>) -><br>       ?map_error:(exn -> 'b <a href="Uq_engines.html#TYPEengine_state">engine_state</a>) -><br>       ?map_aborted:(unit -> 'b <a href="Uq_engines.html#TYPEengine_state">engine_state</a>) -><br>       ?propagate_working:bool -> 'a #<a href="Uq_engines.engine-c.html">engine</a> -> 'b <a href="Uq_engines.engine-c.html">engine</a></code></pre><div class="info ">
Same as function<br>
</div>

<pre><span name="TYPEfmap_engine"><span class="keyword">class</span> <code class="type">[['a, 'b]]</code> <a href="Uq_engines.fmap_engine-c.html">fmap_engine</a></span> : <code class="type">'a #<a href="Uq_engines.engine-c.html">engine</a> -> ('a <a href="Uq_engines.html#TYPEfinal_state">final_state</a> -> 'b <a href="Uq_engines.html#TYPEfinal_state">final_state</a>) -> </code><code class="type">['b]</code> <code class="type"><a href="Uq_engines.engine-c.html">engine</a></code></pre><div class="info">
Similar to <code class="code">map_engine</code> but different calling conventions: The
      mapping function is called when the argument engine reaches a
      final state, and this state can be mapped to another final state.
</div>

<pre><span id="VALfmap_engine"><span class="keyword">val</span> fmap_engine</span> : <code class="type">'a #<a href="Uq_engines.engine-c.html">engine</a> -><br>       ('a <a href="Uq_engines.html#TYPEfinal_state">final_state</a> -> 'b <a href="Uq_engines.html#TYPEfinal_state">final_state</a>) -><br>       'b <a href="Uq_engines.engine-c.html">engine</a></code></pre><div class="info ">
Same as function
<p>

      After opening <a href="Uq_engines.Operators.html"><code class="code">Uq_engines.Operators</code></a>, this is also available
      as operator <code class="code">&gt;&gt;</code>, e.g.
<p>

      <pre class="codepre"><code class="code"> 
         e &gt;&gt;
           (function
             | `Done r -&gt; ...
             | `Error error -&gt; ...
             | `Aborted -&gt; ...
           )
       </code></pre><br>
</div>

<pre><span name="TYPEmeta_engine"><span class="keyword">class</span> <code class="type">['a]</code> <a href="Uq_engines.meta_engine-c.html">meta_engine</a></span> : <code class="type">'a #<a href="Uq_engines.engine-c.html">engine</a> -> </code><code class="type">['a <a href="Uq_engines.html#TYPEfinal_state">final_state</a>]</code> <code class="type"><a href="Uq_engines.engine-c.html">engine</a></code></pre><div class="info">
maps the final state <code class="code">s</code> to <code class="code">`Done s</code>
</div>

<pre><span id="VALmeta_engine"><span class="keyword">val</span> meta_engine</span> : <code class="type">'a #<a href="Uq_engines.engine-c.html">engine</a> -> 'a <a href="Uq_engines.html#TYPEfinal_state">final_state</a> <a href="Uq_engines.engine-c.html">engine</a></code></pre><div class="info ">
Same as function<br>
</div>

<pre><span name="TYPEepsilon_engine"><span class="keyword">class</span> <code class="type">['t]</code> <a href="Uq_engines.epsilon_engine-c.html">epsilon_engine</a></span> : <code class="type">'t <a href="Uq_engines.html#TYPEengine_state">engine_state</a> -> <a href="Unixqueue.event_system-c.html">Unixqueue.event_system</a> -> </code><code class="type">['t]</code> <code class="type"><a href="Uq_engines.engine-c.html">engine</a></code></pre><div class="info">
This engine transitions from its initial state <code class="code">`Working 0</code> in one
 step ("epsilon time") to the passed constant state.
</div>

<pre><span id="VALepsilon_engine"><span class="keyword">val</span> epsilon_engine</span> : <code class="type">'t <a href="Uq_engines.html#TYPEengine_state">engine_state</a> -> <a href="Unixqueue.event_system-c.html">Unixqueue.event_system</a> -> 't <a href="Uq_engines.engine-c.html">engine</a></code></pre><div class="info ">
Same as function<br>
</div>

<pre><span name="TYPEseq_engine"><span class="keyword">class</span> <code class="type">[['a, 'b]]</code> <a href="Uq_engines.seq_engine-c.html">seq_engine</a></span> : <code class="type">'a #<a href="Uq_engines.engine-c.html">engine</a> -> ('a -> 'b #<a href="Uq_engines.engine-c.html">engine</a>) -> </code><code class="type">['b]</code> <code class="type"><a href="Uq_engines.engine-c.html">engine</a></code></pre><div class="info">
This engine runs two engines in sequential order.
</div>

<pre><span id="VALseq_engine"><span class="keyword">val</span> seq_engine</span> : <code class="type">'a #<a href="Uq_engines.engine-c.html">engine</a> -><br>       ('a -> 'b #<a href="Uq_engines.engine-c.html">engine</a>) -> 'b <a href="Uq_engines.engine-c.html">engine</a></code></pre><div class="info ">
Same as function.
<p>

 After opening <a href="Uq_engines.Operators.html"><code class="code">Uq_engines.Operators</code></a>, this is also available
 as operator <code class="code">++</code>, e.g.
 <pre class="codepre"><code class="code"> e1 ++ (fun r1 -&gt; e2) </code></pre>
 (when <code class="code">e1</code> and <code class="code">e2</code> are engines, and <code class="code">r1</code> is the result of <code class="code">e1</code>).<br>
</div>

<pre><span name="TYPEqseq_engine"><span class="keyword">class</span> <code class="type">[['a, 'b]]</code> <a href="Uq_engines.qseq_engine-c.html">qseq_engine</a></span> : <code class="type">'a #<a href="Uq_engines.engine-c.html">engine</a> -> ('a -> 'b #<a href="Uq_engines.engine-c.html">engine</a>) -> </code><code class="type">['b]</code> <code class="type"><a href="Uq_engines.engine-c.html">engine</a></code></pre>
<pre><span id="VALqseq_engine"><span class="keyword">val</span> qseq_engine</span> : <code class="type">'a #<a href="Uq_engines.engine-c.html">engine</a> -><br>       ('a -> 'b #<a href="Uq_engines.engine-c.html">engine</a>) -> 'b <a href="Uq_engines.engine-c.html">engine</a></code></pre><div class="info ">
Almost the same as <code class="code">seq_engine</code>, but this version does not
      propagate working state (i.e. no progress reporting).
<p>

      <code class="code">qseq_engine</code> should be preferred for recursive chains of engines.<br>
</div>

<pre><span name="TYPEstream_seq_engine"><span class="keyword">class</span> <code class="type">['a]</code> <a href="Uq_engines.stream_seq_engine-c.html">stream_seq_engine</a></span> : <code class="type">'a -> ('a -> 'a #<a href="Uq_engines.engine-c.html">engine</a>) Stream.t -> <a href="Unixqueue.event_system-c.html">Unixqueue.event_system</a> -> </code><code class="type">['a]</code> <code class="type"><a href="Uq_engines.engine-c.html">engine</a></code></pre><div class="info">
<code class="code">let se = new stream_seq_engine x0 s esys</code>: The constructed engine <code class="code">se</code>
 fetches functions <code class="code">f : 'a -&gt; 'a #engine</code> from the stream <code class="code">s</code>, and
 runs the engines obtained by calling these functions <code class="code">e = f x</code> one
 after the other.
</div>

<pre><span id="VALstream_seq_engine"><span class="keyword">val</span> stream_seq_engine</span> : <code class="type">'a -><br>       ('a -> 'a #<a href="Uq_engines.engine-c.html">engine</a>) Stream.t -><br>       <a href="Unixqueue.event_system-c.html">Unixqueue.event_system</a> -> 'a <a href="Uq_engines.engine-c.html">engine</a></code></pre><div class="info ">
Same as function<br>
</div>

<pre><span name="TYPEsync_engine"><span class="keyword">class</span> <code class="type">[['a, 'b]]</code> <a href="Uq_engines.sync_engine-c.html">sync_engine</a></span> : <code class="type">'a #<a href="Uq_engines.engine-c.html">engine</a> -> 'b #<a href="Uq_engines.engine-c.html">engine</a> -> </code><code class="type">[('a * 'b)]</code> <code class="type"><a href="Uq_engines.engine-c.html">engine</a></code></pre><div class="info">
This engine runs two engines in parallel, and waits until both
 are <code class="code">`Done</code> (synchronization).
</div>

<pre><span id="VALsync_engine"><span class="keyword">val</span> sync_engine</span> : <code class="type">'a #<a href="Uq_engines.engine-c.html">engine</a> -> 'b #<a href="Uq_engines.engine-c.html">engine</a> -> ('a * 'b) <a href="Uq_engines.engine-c.html">engine</a></code></pre><div class="info ">
Same as function<br>
</div>

<pre><span name="TYPEmsync_engine"><span class="keyword">class</span> <code class="type">[['a, 'b]]</code> <a href="Uq_engines.msync_engine-c.html">msync_engine</a></span> : <code class="type">'a #<a href="Uq_engines.engine-c.html">engine</a> list -> ('a -> 'b -> 'b) -> 'b -> <a href="Unixqueue.event_system-c.html">Unixqueue.event_system</a> -> </code><code class="type">['b]</code> <code class="type"><a href="Uq_engines.engine-c.html">engine</a></code></pre><div class="info">
Multiple synchronization: 
      <code class="code">let me = new msync_engine el f x0 esys</code> - Runs the engines in <code class="code">el</code> in
      parallel, and waits until all are <code class="code">`Done</code>.
</div>

<pre><span id="VALmsync_engine"><span class="keyword">val</span> msync_engine</span> : <code class="type">'a #<a href="Uq_engines.engine-c.html">engine</a> list -><br>       ('a -> 'b -> 'b) -> 'b -> <a href="Unixqueue.event_system-c.html">Unixqueue.event_system</a> -> 'b <a href="Uq_engines.engine-c.html">engine</a></code></pre><div class="info ">
Same as function<br>
</div>

<pre><span name="TYPEdelay_engine"><span class="keyword">class</span> <code class="type">['a]</code> <a href="Uq_engines.delay_engine-c.html">delay_engine</a></span> : <code class="type">float -> (unit -> 'a #<a href="Uq_engines.engine-c.html">engine</a>) -> <a href="Unixqueue.event_system-c.html">Unixqueue.event_system</a> -> </code><code class="type">['a]</code> <code class="type"><a href="Uq_engines.engine-c.html">engine</a></code></pre><div class="info">
<code class="code">let de = delay_engine d f esys</code>: The engine <code class="code">e = f()</code> is created
      after <code class="code">d</code> seconds, and the result of <code class="code">e</code> becomes the result of <code class="code">de</code>.
</div>

<pre><span id="VALdelay_engine"><span class="keyword">val</span> delay_engine</span> : <code class="type">float -><br>       (unit -> 'a #<a href="Uq_engines.engine-c.html">engine</a>) -><br>       <a href="Unixqueue.event_system-c.html">Unixqueue.event_system</a> -> 'a <a href="Uq_engines.engine-c.html">engine</a></code></pre><div class="info ">
Same as function<br>
</div>

<pre><span name="TYPEtimeout_engine"><span class="keyword">class</span> <code class="type">['a]</code> <a href="Uq_engines.timeout_engine-c.html">timeout_engine</a></span> : <code class="type">float -> exn -> 'a <a href="Uq_engines.engine-c.html">engine</a> -> </code><code class="type">['a]</code> <code class="type"><a href="Uq_engines.engine-c.html">engine</a></code></pre><div class="info">
<code class="code">timeout_engine d x e</code>: If the engine <code class="code">e</code> finishes within <code class="code">d</code>
      seconds, the result remains unchanged.
</div>

<pre><span id="VALtimeout_engine"><span class="keyword">val</span> timeout_engine</span> : <code class="type">float -> exn -> 'a <a href="Uq_engines.engine-c.html">engine</a> -> 'a <a href="Uq_engines.engine-c.html">engine</a></code></pre><div class="info ">
Same as function<br>
</div>

<pre><span name="TYPEwatchdog"><span class="keyword">class</span> <a href="Uq_engines.watchdog-c.html">watchdog</a></span> : <code class="type">float -> 'a #<a href="Uq_engines.engine-c.html">engine</a> -> </code><code class="type">[unit]</code> <code class="type"><a href="Uq_engines.engine-c.html">engine</a></code></pre><div class="info">
A watchdog engine checks whether the argument engine makes
 progress, and if there is no progress for the passed number of
 seconds, the engine is aborted, and the watchdog state changes
 to <code class="code">`Error Watchdog_timeout</code>.
</div>

<pre><span id="VALwatchdog"><span class="keyword">val</span> watchdog</span> : <code class="type">float -> 'a #<a href="Uq_engines.engine-c.html">engine</a> -> unit <a href="Uq_engines.engine-c.html">engine</a></code></pre><div class="info ">
Same as function<br>
</div>

<pre><span id="TYPEserializer_t"><span class="keyword">class type</span> <code class="type">['a]</code> <a href="Uq_engines.serializer_t-c.html">serializer_t</a></span> = <code class="code">object</code> <a href="Uq_engines.serializer_t-c.html">..</a> <code class="code">end</code></pre><div class="info">
A serializer queues up engines, and starts the next engine when the
      previous one finishes.
</div>

<pre><span name="TYPEserializer"><span class="keyword">class</span> <code class="type">['a]</code> <a href="Uq_engines.serializer-c.html">serializer</a></span> : <code class="type"><a href="Unixqueue.event_system-c.html">Unixqueue.event_system</a> -> </code><code class="type">['a]</code> <code class="type"><a href="Uq_engines.serializer_t-c.html">serializer_t</a></code></pre><div class="info">
Creates a serializer
</div>

<pre><span id="VALserializer"><span class="keyword">val</span> serializer</span> : <code class="type"><a href="Unixqueue.event_system-c.html">Unixqueue.event_system</a> -> 'a <a href="Uq_engines.serializer_t-c.html">serializer_t</a></code></pre><div class="info ">
Same as function<br>
</div>

<pre><span id="TYPEprioritizer_t"><span class="keyword">class type</span> <code class="type">['a]</code> <a href="Uq_engines.prioritizer_t-c.html">prioritizer_t</a></span> = <code class="code">object</code> <a href="Uq_engines.prioritizer_t-c.html">..</a> <code class="code">end</code></pre><div class="info">
A prioritizer allows to prioritize the execution of engines: At any
    time, only engines of a certain priority <code class="code">p</code> can be executed.
</div>

<pre><span name="TYPEprioritizer"><span class="keyword">class</span> <code class="type">['a]</code> <a href="Uq_engines.prioritizer-c.html">prioritizer</a></span> : <code class="type"><a href="Unixqueue.event_system-c.html">Unixqueue.event_system</a> -> </code><code class="type">['a]</code> <code class="type"><a href="Uq_engines.prioritizer_t-c.html">prioritizer_t</a></code></pre><div class="info">
Creates a prioritizer
</div>

<pre><span id="VALprioritizer"><span class="keyword">val</span> prioritizer</span> : <code class="type"><a href="Unixqueue.event_system-c.html">Unixqueue.event_system</a> -> 'a <a href="Uq_engines.prioritizer_t-c.html">prioritizer_t</a></code></pre><div class="info ">
Same as function<br>
</div>

<pre><span id="TYPEcache_t"><span class="keyword">class type</span> <code class="type">['a]</code> <a href="Uq_engines.cache_t-c.html">cache_t</a></span> = <code class="code">object</code> <a href="Uq_engines.cache_t-c.html">..</a> <code class="code">end</code></pre><div class="info">
A cache contains a mutable value that is obtained by running an
    engine.
</div>

<pre><span name="TYPEcache"><span class="keyword">class</span> <code class="type">['a]</code> <a href="Uq_engines.cache-c.html">cache</a></span> : <code class="type">(<a href="Unixqueue.event_system-c.html">Unixqueue.event_system</a> -> 'a <a href="Uq_engines.engine-c.html">engine</a>) -> <a href="Unixqueue.event_system-c.html">Unixqueue.event_system</a> -> </code><code class="type">['a]</code> <code class="type"><a href="Uq_engines.cache_t-c.html">cache_t</a></code></pre><div class="info">
<code class="code">new cache f esys</code>: A cache that runs <code class="code">f esys</code> to obtain values
</div>

<pre><span id="VALcache"><span class="keyword">val</span> cache</span> : <code class="type">(<a href="Unixqueue.event_system-c.html">Unixqueue.event_system</a> -> 'a <a href="Uq_engines.engine-c.html">engine</a>) -><br>       <a href="Unixqueue.event_system-c.html">Unixqueue.event_system</a> -> 'a <a href="Uq_engines.cache_t-c.html">cache_t</a></code></pre><div class="info ">
Same as function<br>
</div>

<pre><span name="TYPEengine_mixin"><span class="keyword">class</span> <code class="type">['t]</code> <a href="Uq_engines.engine_mixin-c.html">engine_mixin</a></span> : <code class="type">'t <a href="Uq_engines.html#TYPEengine_state">engine_state</a> -> <a href="Unixqueue.event_system-c.html">Unixqueue.event_system</a> -> </code><code class="code">object</code> <a href="Uq_engines.engine_mixin-c.html">..</a> <code class="code">end</code></pre><div class="info">
A useful class fragment that implements <code class="code">state</code> and 
 <code class="code">request_notification</code>.
</div>

<pre><span class="keyword">module</span> <a href="Uq_engines.Operators.html">Operators</a>: <code class="code">sig</code> <a href="Uq_engines.Operators.html">..</a> <code class="code">end</code></pre><div class="info">
Handy operators: <code class="code">++</code>, <code class="code">&gt;&gt;</code>, and <code class="code">eps_e</code>
</div>
<br>
<h1 id="1_BasicIOengines">Basic I/O engines</h1><br>

<pre><span name="TYPEpoll_engine"><span class="keyword">class</span> <a href="Uq_engines.poll_engine-c.html">poll_engine</a></span> : <code class="type">?extra_match:exn -> bool -> (<a href="Unixqueue.html#TYPEoperation">Unixqueue.operation</a> * float) list -> <a href="Unixqueue.event_system-c.html">Unixqueue.event_system</a> -> </code><code class="code">object</code> <a href="Uq_engines.poll_engine-c.html">..</a> <code class="code">end</code></pre><div class="info">
This engine waits until one of the passed operations can be 
 carried out, or until one of the operations times out.
</div>

<pre><span name="TYPEinput_engine"><span class="keyword">class</span> <code class="type">['a]</code> <a href="Uq_engines.input_engine-c.html">input_engine</a></span> : <code class="type">(Unix.file_descr -> 'a) -> Unix.file_descr -> float -> <a href="Unixqueue.event_system-c.html">Unixqueue.event_system</a> -> </code><code class="type">['a]</code> <code class="type"><a href="Uq_engines.engine-c.html">engine</a></code></pre><div class="info">
Generic input engine for reading from a file descriptor:
      <code class="code">let e = new input_engine f fd tmo</code> - Waits until the file descriptor
      becomes readable, and calls then <code class="code">let x = f fd</code> to read from the
      descriptor.
</div>

<pre><span name="TYPEoutput_engine"><span class="keyword">class</span> <code class="type">['a]</code> <a href="Uq_engines.output_engine-c.html">output_engine</a></span> : <code class="type">(Unix.file_descr -> 'a) -> Unix.file_descr -> float -> <a href="Unixqueue.event_system-c.html">Unixqueue.event_system</a> -> </code><code class="type">['a]</code> <code class="type"><a href="Uq_engines.engine-c.html">engine</a></code></pre><div class="info">
Generic output engine for writing to a file descriptor:
      <code class="code">let e = new output_engine f fd tmo</code> - Waits until the file descriptor
      becomes writable, and calls then <code class="code">let x = f fd</code> to write to the
      descriptor.
</div>

<pre><span name="TYPEpoll_process_engine"><span class="keyword">class</span> <a href="Uq_engines.poll_process_engine-c.html">poll_process_engine</a></span> : <code class="type">?period:float -> pid:int -> <a href="Unixqueue.event_system-c.html">Unixqueue.event_system</a> -> </code><code class="type">[Unix.process_status]</code> <code class="type"><a href="Uq_engines.engine-c.html">engine</a></code></pre><div class="info">
<b>This class is deprecated!</b> Use the classes in <a href="Shell_uq.html"><code class="code">Shell_uq</code></a> instead.
</div>
<br>
<h2 id="2_MoreIO">More I/O</h2>
<p>

    The module <a href="Uq_io.html"><code class="code">Uq_io</code></a> provides a bunch of functions to read and write
    data via various "devices". All these functions return engines, and
    are easy to use. Devices can be file descriptors, but also other
    data structures. In particular, there is also support for buffered I/O
    and for reading line-by-line from an input device.<br>
<br>
<h2 id="2_MoreIO">More I/O</h2>
<p>

    The module <a href="Uq_io.html"><code class="code">Uq_io</code></a> provides a bunch of functions to read and write
    data via various "devices". All these functions return engines, and
    are easy to use. Devices can be file descriptors, but also other
    data structures. In particular, there is also support for buffered I/O
    and for reading line-by-line from an input device.<br>
<br>
<h1 id="1_Recursion">Recursion</h1><br>
<br>
<h2 id="2_MoreIO">More I/O</h2>
<p>

    The module <a href="Uq_io.html"><code class="code">Uq_io</code></a> provides a bunch of functions to read and write
    data via various "devices". All these functions return engines, and
    are easy to use. Devices can be file descriptors, but also other
    data structures. In particular, there is also support for buffered I/O
    and for reading line-by-line from an input device.<br>
<br>
<h1 id="1_Recursion">Recursion</h1><br>
<br>
When programming with engines, it is normal to use recursion for any
    kind of loops. For example, to read the lines from a file:
<p>

    <pre class="codepre"><code class="code">      open Uq_engines.Operators  (* for "&gt;&gt;" and "++" *)

      let fd = 
        Unix.openfile filename [Unix.O_RDONLY] 0 in
      let d = 
        `Buffer_in(Uq_io.create_in_buffer(`Polldescr(`Read_write,fd,esys))) in

      let rec read_lines acc =
        Uq_io.input_line_e d &gt;&gt;
          (function                       (* catch exception End_of_file *)
            | `Done line -&gt; `Done(Some line)
            | `Error End_of_file -&gt; `Done None
            | `Error error -&gt; `Error error
            | `Aborted -&gt; `Aborted
          ) ++
          (function
            | Some line -&gt;
                read_lines (line :: acc)
            | None -&gt;
                eps_e (`Done (List.rev acc)) esys
          ) in

      let e = read_lines []
    </code></pre>
<p>

    There is generally the question whether this style leads to stack
    overflows. This depends on the mechanisms that come into play:
<p>
<ul>
<li>The engine mechanism passing control from one engine to the next is
      not tail-recursive, and thus the stack can overflow when the
      recursion becomes too deep</li>
<li>The event queue mechanism, however, does not have this problem.
      Control falls automatically back to the event queue whenever I/O
      needs to be done.</li>
</ul>

    In this example, this means that only the engine mechanism is used
    as long as the data is read from the buffer. When the buffer needs
    to be refilled, however, control is passed back to the event queue
    (so the stack is cleaned), and the continuation of the execution
    is only managed via closures (which only allocate memory on the
    heap, not on the stack). Usually, this is a good compromise: The
    engine mechnism is a lot faster, but I/O is an indicator for using
    the better but slower technique.
<p>

    Also note another difference: The event queue mechanism allows that
    other asynchronous code attached to the same event queue may run
    (control maybe yielded to unrelated execution contexts). The
    pure engine mechanism does not allow that. This may be handy when
    exclusive access to variables is needed. (But be careful here -
    this is very sensitive to minimal changes of the implementation.)
<p>

    Certain engines enforce using the event queue mechanisms although they
    are unrelated to I/O. Especially <a href="Uq_engines.html#VALdelay_engine"><code class="code">Uq_engines.delay_engine</code></a> is
    useful here: A "delay" of 0 seconds is already sufficient to
    go back to the event queue. If recursions sometimes lead to
    stack overflows the solution is to include such a zero delay
    before doing the self call.<br>
<br>
<h2 id="2_MoreIO">More I/O</h2>
<p>

    The module <a href="Uq_io.html"><code class="code">Uq_io</code></a> provides a bunch of functions to read and write
    data via various "devices". All these functions return engines, and
    are easy to use. Devices can be file descriptors, but also other
    data structures. In particular, there is also support for buffered I/O
    and for reading line-by-line from an input device.<br>
<br>
<h1 id="1_Recursion">Recursion</h1><br>
<br>
When programming with engines, it is normal to use recursion for any
    kind of loops. For example, to read the lines from a file:
<p>

    <pre class="codepre"><code class="code">      open Uq_engines.Operators  (* for "&gt;&gt;" and "++" *)

      let fd = 
        Unix.openfile filename [Unix.O_RDONLY] 0 in
      let d = 
        `Buffer_in(Uq_io.create_in_buffer(`Polldescr(`Read_write,fd,esys))) in

      let rec read_lines acc =
        Uq_io.input_line_e d &gt;&gt;
          (function                       (* catch exception End_of_file *)
            | `Done line -&gt; `Done(Some line)
            | `Error End_of_file -&gt; `Done None
            | `Error error -&gt; `Error error
            | `Aborted -&gt; `Aborted
          ) ++
          (function
            | Some line -&gt;
                read_lines (line :: acc)
            | None -&gt;
                eps_e (`Done (List.rev acc)) esys
          ) in

      let e = read_lines []
    </code></pre>
<p>

    There is generally the question whether this style leads to stack
    overflows. This depends on the mechanisms that come into play:
<p>
<ul>
<li>The engine mechanism passing control from one engine to the next is
      not tail-recursive, and thus the stack can overflow when the
      recursion becomes too deep</li>
<li>The event queue mechanism, however, does not have this problem.
      Control falls automatically back to the event queue whenever I/O
      needs to be done.</li>
</ul>

    In this example, this means that only the engine mechanism is used
    as long as the data is read from the buffer. When the buffer needs
    to be refilled, however, control is passed back to the event queue
    (so the stack is cleaned), and the continuation of the execution
    is only managed via closures (which only allocate memory on the
    heap, not on the stack). Usually, this is a good compromise: The
    engine mechnism is a lot faster, but I/O is an indicator for using
    the better but slower technique.
<p>

    Also note another difference: The event queue mechanism allows that
    other asynchronous code attached to the same event queue may run
    (control maybe yielded to unrelated execution contexts). The
    pure engine mechanism does not allow that. This may be handy when
    exclusive access to variables is needed. (But be careful here -
    this is very sensitive to minimal changes of the implementation.)
<p>

    Certain engines enforce using the event queue mechanisms although they
    are unrelated to I/O. Especially <a href="Uq_engines.html#VALdelay_engine"><code class="code">Uq_engines.delay_engine</code></a> is
    useful here: A "delay" of 0 seconds is already sufficient to
    go back to the event queue. If recursions sometimes lead to
    stack overflows the solution is to include such a zero delay
    before doing the self call.<br>
<br>
<h1 id="1_MoreEngines">More Engines</h1><br>
<br>
<h2 id="2_MoreIO">More I/O</h2>
<p>

    The module <a href="Uq_io.html"><code class="code">Uq_io</code></a> provides a bunch of functions to read and write
    data via various "devices". All these functions return engines, and
    are easy to use. Devices can be file descriptors, but also other
    data structures. In particular, there is also support for buffered I/O
    and for reading line-by-line from an input device.<br>
<br>
<h1 id="1_Recursion">Recursion</h1><br>
<br>
When programming with engines, it is normal to use recursion for any
    kind of loops. For example, to read the lines from a file:
<p>

    <pre class="codepre"><code class="code">      open Uq_engines.Operators  (* for "&gt;&gt;" and "++" *)

      let fd = 
        Unix.openfile filename [Unix.O_RDONLY] 0 in
      let d = 
        `Buffer_in(Uq_io.create_in_buffer(`Polldescr(`Read_write,fd,esys))) in

      let rec read_lines acc =
        Uq_io.input_line_e d &gt;&gt;
          (function                       (* catch exception End_of_file *)
            | `Done line -&gt; `Done(Some line)
            | `Error End_of_file -&gt; `Done None
            | `Error error -&gt; `Error error
            | `Aborted -&gt; `Aborted
          ) ++
          (function
            | Some line -&gt;
                read_lines (line :: acc)
            | None -&gt;
                eps_e (`Done (List.rev acc)) esys
          ) in

      let e = read_lines []
    </code></pre>
<p>

    There is generally the question whether this style leads to stack
    overflows. This depends on the mechanisms that come into play:
<p>
<ul>
<li>The engine mechanism passing control from one engine to the next is
      not tail-recursive, and thus the stack can overflow when the
      recursion becomes too deep</li>
<li>The event queue mechanism, however, does not have this problem.
      Control falls automatically back to the event queue whenever I/O
      needs to be done.</li>
</ul>

    In this example, this means that only the engine mechanism is used
    as long as the data is read from the buffer. When the buffer needs
    to be refilled, however, control is passed back to the event queue
    (so the stack is cleaned), and the continuation of the execution
    is only managed via closures (which only allocate memory on the
    heap, not on the stack). Usually, this is a good compromise: The
    engine mechnism is a lot faster, but I/O is an indicator for using
    the better but slower technique.
<p>

    Also note another difference: The event queue mechanism allows that
    other asynchronous code attached to the same event queue may run
    (control maybe yielded to unrelated execution contexts). The
    pure engine mechanism does not allow that. This may be handy when
    exclusive access to variables is needed. (But be careful here -
    this is very sensitive to minimal changes of the implementation.)
<p>

    Certain engines enforce using the event queue mechanisms although they
    are unrelated to I/O. Especially <a href="Uq_engines.html#VALdelay_engine"><code class="code">Uq_engines.delay_engine</code></a> is
    useful here: A "delay" of 0 seconds is already sufficient to
    go back to the event queue. If recursions sometimes lead to
    stack overflows the solution is to include such a zero delay
    before doing the self call.<br>
<br>
<h1 id="1_MoreEngines">More Engines</h1><br>
<br>
Pointers to other modules related to engines:
<p>
<ul>
<li><a href="Uq_client.html"><code class="code">Uq_client</code></a></li>
<li><a href="Uq_server.html"><code class="code">Uq_server</code></a></li>
<li><a href="Uq_multiplex.html"><code class="code">Uq_multiplex</code></a></li>
<li><a href="Uq_transfer.html"><code class="code">Uq_transfer</code></a></li>
<li><a href="Uq_datagram.html"><code class="code">Uq_datagram</code></a></li>
<li><a href="Uq_io.html"><code class="code">Uq_io</code></a></li>
<li>RPC clients: The function <a href="Rpc_proxy.ManagedClient.html#VALrpc_engine"><code class="code">Rpc_proxy.ManagedClient.rpc_engine</code></a> allows
    to call an RPC via an engine. When the call is done, the engine transitions
    to <code class="code">`Done r</code>, and <code class="code">r</code> is the result of the remote call.</li>
<li>Subprograms: The class <a href="Shell_uq.call_engine-c.html"><code class="code">Shell_uq.call_engine</code></a> allows to start an
    external program, and to monitor it via an engine.</li>
</ul>
<br>
<br>
<h2 id="2_MoreIO">More I/O</h2>
<p>

    The module <a href="Uq_io.html"><code class="code">Uq_io</code></a> provides a bunch of functions to read and write
    data via various "devices". All these functions return engines, and
    are easy to use. Devices can be file descriptors, but also other
    data structures. In particular, there is also support for buffered I/O
    and for reading line-by-line from an input device.<br>
<br>
<h1 id="1_Recursion">Recursion</h1><br>
<br>
When programming with engines, it is normal to use recursion for any
    kind of loops. For example, to read the lines from a file:
<p>

    <pre class="codepre"><code class="code">      open Uq_engines.Operators  (* for "&gt;&gt;" and "++" *)

      let fd = 
        Unix.openfile filename [Unix.O_RDONLY] 0 in
      let d = 
        `Buffer_in(Uq_io.create_in_buffer(`Polldescr(`Read_write,fd,esys))) in

      let rec read_lines acc =
        Uq_io.input_line_e d &gt;&gt;
          (function                       (* catch exception End_of_file *)
            | `Done line -&gt; `Done(Some line)
            | `Error End_of_file -&gt; `Done None
            | `Error error -&gt; `Error error
            | `Aborted -&gt; `Aborted
          ) ++
          (function
            | Some line -&gt;
                read_lines (line :: acc)
            | None -&gt;
                eps_e (`Done (List.rev acc)) esys
          ) in

      let e = read_lines []
    </code></pre>
<p>

    There is generally the question whether this style leads to stack
    overflows. This depends on the mechanisms that come into play:
<p>
<ul>
<li>The engine mechanism passing control from one engine to the next is
      not tail-recursive, and thus the stack can overflow when the
      recursion becomes too deep</li>
<li>The event queue mechanism, however, does not have this problem.
      Control falls automatically back to the event queue whenever I/O
      needs to be done.</li>
</ul>

    In this example, this means that only the engine mechanism is used
    as long as the data is read from the buffer. When the buffer needs
    to be refilled, however, control is passed back to the event queue
    (so the stack is cleaned), and the continuation of the execution
    is only managed via closures (which only allocate memory on the
    heap, not on the stack). Usually, this is a good compromise: The
    engine mechnism is a lot faster, but I/O is an indicator for using
    the better but slower technique.
<p>

    Also note another difference: The event queue mechanism allows that
    other asynchronous code attached to the same event queue may run
    (control maybe yielded to unrelated execution contexts). The
    pure engine mechanism does not allow that. This may be handy when
    exclusive access to variables is needed. (But be careful here -
    this is very sensitive to minimal changes of the implementation.)
<p>

    Certain engines enforce using the event queue mechanisms although they
    are unrelated to I/O. Especially <a href="Uq_engines.html#VALdelay_engine"><code class="code">Uq_engines.delay_engine</code></a> is
    useful here: A "delay" of 0 seconds is already sufficient to
    go back to the event queue. If recursions sometimes lead to
    stack overflows the solution is to include such a zero delay
    before doing the self call.<br>
<br>
<h1 id="1_MoreEngines">More Engines</h1><br>
<br>
Pointers to other modules related to engines:
<p>
<ul>
<li><a href="Uq_client.html"><code class="code">Uq_client</code></a></li>
<li><a href="Uq_server.html"><code class="code">Uq_server</code></a></li>
<li><a href="Uq_multiplex.html"><code class="code">Uq_multiplex</code></a></li>
<li><a href="Uq_transfer.html"><code class="code">Uq_transfer</code></a></li>
<li><a href="Uq_datagram.html"><code class="code">Uq_datagram</code></a></li>
<li><a href="Uq_io.html"><code class="code">Uq_io</code></a></li>
<li>RPC clients: The function <a href="Rpc_proxy.ManagedClient.html#VALrpc_engine"><code class="code">Rpc_proxy.ManagedClient.rpc_engine</code></a> allows
    to call an RPC via an engine. When the call is done, the engine transitions
    to <code class="code">`Done r</code>, and <code class="code">r</code> is the result of the remote call.</li>
<li>Subprograms: The class <a href="Shell_uq.call_engine-c.html"><code class="code">Shell_uq.call_engine</code></a> allows to start an
    external program, and to monitor it via an engine.</li>
</ul>
<br>
<br>
<h1 id="1_Moved">Moved</h1><br>
<br>
<h2 id="2_MoreIO">More I/O</h2>
<p>

    The module <a href="Uq_io.html"><code class="code">Uq_io</code></a> provides a bunch of functions to read and write
    data via various "devices". All these functions return engines, and
    are easy to use. Devices can be file descriptors, but also other
    data structures. In particular, there is also support for buffered I/O
    and for reading line-by-line from an input device.<br>
<br>
<h1 id="1_Recursion">Recursion</h1><br>
<br>
When programming with engines, it is normal to use recursion for any
    kind of loops. For example, to read the lines from a file:
<p>

    <pre class="codepre"><code class="code">      open Uq_engines.Operators  (* for "&gt;&gt;" and "++" *)

      let fd = 
        Unix.openfile filename [Unix.O_RDONLY] 0 in
      let d = 
        `Buffer_in(Uq_io.create_in_buffer(`Polldescr(`Read_write,fd,esys))) in

      let rec read_lines acc =
        Uq_io.input_line_e d &gt;&gt;
          (function                       (* catch exception End_of_file *)
            | `Done line -&gt; `Done(Some line)
            | `Error End_of_file -&gt; `Done None
            | `Error error -&gt; `Error error
            | `Aborted -&gt; `Aborted
          ) ++
          (function
            | Some line -&gt;
                read_lines (line :: acc)
            | None -&gt;
                eps_e (`Done (List.rev acc)) esys
          ) in

      let e = read_lines []
    </code></pre>
<p>

    There is generally the question whether this style leads to stack
    overflows. This depends on the mechanisms that come into play:
<p>
<ul>
<li>The engine mechanism passing control from one engine to the next is
      not tail-recursive, and thus the stack can overflow when the
      recursion becomes too deep</li>
<li>The event queue mechanism, however, does not have this problem.
      Control falls automatically back to the event queue whenever I/O
      needs to be done.</li>
</ul>

    In this example, this means that only the engine mechanism is used
    as long as the data is read from the buffer. When the buffer needs
    to be refilled, however, control is passed back to the event queue
    (so the stack is cleaned), and the continuation of the execution
    is only managed via closures (which only allocate memory on the
    heap, not on the stack). Usually, this is a good compromise: The
    engine mechnism is a lot faster, but I/O is an indicator for using
    the better but slower technique.
<p>

    Also note another difference: The event queue mechanism allows that
    other asynchronous code attached to the same event queue may run
    (control maybe yielded to unrelated execution contexts). The
    pure engine mechanism does not allow that. This may be handy when
    exclusive access to variables is needed. (But be careful here -
    this is very sensitive to minimal changes of the implementation.)
<p>

    Certain engines enforce using the event queue mechanisms although they
    are unrelated to I/O. Especially <a href="Uq_engines.html#VALdelay_engine"><code class="code">Uq_engines.delay_engine</code></a> is
    useful here: A "delay" of 0 seconds is already sufficient to
    go back to the event queue. If recursions sometimes lead to
    stack overflows the solution is to include such a zero delay
    before doing the self call.<br>
<br>
<h1 id="1_MoreEngines">More Engines</h1><br>
<br>
Pointers to other modules related to engines:
<p>
<ul>
<li><a href="Uq_client.html"><code class="code">Uq_client</code></a></li>
<li><a href="Uq_server.html"><code class="code">Uq_server</code></a></li>
<li><a href="Uq_multiplex.html"><code class="code">Uq_multiplex</code></a></li>
<li><a href="Uq_transfer.html"><code class="code">Uq_transfer</code></a></li>
<li><a href="Uq_datagram.html"><code class="code">Uq_datagram</code></a></li>
<li><a href="Uq_io.html"><code class="code">Uq_io</code></a></li>
<li>RPC clients: The function <a href="Rpc_proxy.ManagedClient.html#VALrpc_engine"><code class="code">Rpc_proxy.ManagedClient.rpc_engine</code></a> allows
    to call an RPC via an engine. When the call is done, the engine transitions
    to <code class="code">`Done r</code>, and <code class="code">r</code> is the result of the remote call.</li>
<li>Subprograms: The class <a href="Shell_uq.call_engine-c.html"><code class="code">Shell_uq.call_engine</code></a> allows to start an
    external program, and to monitor it via an engine.</li>
</ul>
<br>
<br>
<h1 id="1_Moved">Moved</h1><br>
<br>
OCamlnet-4.0 moves a number of definitions to the modules<ul>
<li><a href="Uq_transfer.html"><code class="code">Uq_transfer</code></a></li>
<li><a href="Uq_multiplex.html"><code class="code">Uq_multiplex</code></a></li>
</ul>

    For convenience, the types are still also exported here, but
    functions and classes are now defined in these modules.
    See also the module <a href="Uq_engines_compat.html"><code class="code">Uq_engines_compat</code></a>.<br>

<pre><span id="TYPEasync_out_channel"><span class="keyword">class type</span> <a href="Uq_engines.async_out_channel-c.html">async_out_channel</a></span> = <code class="code">object</code> <a href="Uq_engines.async_out_channel-c.html">..</a> <code class="code">end</code></pre><div class="info">
Moved to <a href="Uq_transfer.async_out_channel-c.html"><code class="code">Uq_transfer.async_out_channel</code></a>
</div>

<pre><span id="TYPEasync_in_channel"><span class="keyword">class type</span> <a href="Uq_engines.async_in_channel-c.html">async_in_channel</a></span> = <code class="code">object</code> <a href="Uq_engines.async_in_channel-c.html">..</a> <code class="code">end</code></pre><div class="info">
Moved to <a href="Uq_transfer.async_in_channel-c.html"><code class="code">Uq_transfer.async_in_channel</code></a>
</div>

<pre><span id="TYPEasync_out_channel_engine"><span class="keyword">class type</span> <a href="Uq_engines.async_out_channel_engine-c.html">async_out_channel_engine</a></span> = <code class="code">object</code> <a href="Uq_engines.async_out_channel_engine-c.html">..</a> <code class="code">end</code></pre><div class="info">
Moved to <a href="Uq_transfer.async_out_channel_engine-c.html"><code class="code">Uq_transfer.async_out_channel_engine</code></a>
</div>

<pre><span id="TYPEcopy_task"><span class="keyword">type</span> <code class="type"></code>copy_task</span> = <code class="type">[ `Bidirectional of Unix.file_descr * Unix.file_descr<br>       | `Tridirectional of Unix.file_descr * Unix.file_descr * Unix.file_descr<br>       | `Uni_socket of Unix.file_descr * Unix.file_descr<br>       | `Unidirectional of Unix.file_descr * Unix.file_descr ]</code> </pre>
<div class="info ">
Moved to <a href="Uq_transfer.html#TYPEcopy_task"><code class="code">Uq_transfer.copy_task</code></a><br>
</div>


<pre><span id="TYPEasync_in_channel_engine"><span class="keyword">class type</span> <a href="Uq_engines.async_in_channel_engine-c.html">async_in_channel_engine</a></span> = <code class="code">object</code> <a href="Uq_engines.async_in_channel_engine-c.html">..</a> <code class="code">end</code></pre><div class="info">
Moved to <a href="Uq_transfer.async_in_channel_engine-c.html"><code class="code">Uq_transfer.async_in_channel_engine</code></a>
</div>

<pre><span id="TYPEmultiplex_controller"><span class="keyword">class type</span> <a href="Uq_engines.multiplex_controller-c.html">multiplex_controller</a></span> = <code class="code">object</code> <a href="Uq_engines.multiplex_controller-c.html">..</a> <code class="code">end</code></pre><div class="info">
This definition has now been moved to <a href="Uq_multiplex.multiplex_controller-c.html"><code class="code">Uq_multiplex.multiplex_controller</code></a>
</div>

<pre><span id="EXCEPTIONMem_not_supported"><span class="keyword">exception</span> Mem_not_supported</span></pre>
<div class="info ">
Moved to <a href="Uq_multiplex.html#EXCEPTIONMem_not_supported"><code class="code">Uq_multiplex.Mem_not_supported</code></a><br>
</div>

<pre><span id="TYPEdatagram_multiplex_controller"><span class="keyword">class type</span> <a href="Uq_engines.datagram_multiplex_controller-c.html">datagram_multiplex_controller</a></span> = <code class="code">object</code> <a href="Uq_engines.datagram_multiplex_controller-c.html">..</a> <code class="code">end</code></pre><div class="info">
Moved to <a href="Uq_multiplex.datagram_multiplex_controller-c.html"><code class="code">Uq_multiplex.datagram_multiplex_controller</code></a>
</div>

<pre><span id="TYPEonshutdown_out_spec"><span class="keyword">type</span> <code class="type"></code>onshutdown_out_spec</span> = <code class="type">[ `Action of<br>           <a href="Uq_engines.async_out_channel_engine-c.html">async_out_channel_engine</a> -><br>           <a href="Uq_engines.multiplex_controller-c.html">multiplex_controller</a> -> unit <a href="Uq_engines.html#TYPEengine_state">engine_state</a> -> unit<br>       | `Ignore<br>       | `Initiate_shutdown ]</code> </pre>
<div class="info ">
Moved to <a href="Uq_transfer.html#TYPEonshutdown_out_spec"><code class="code">Uq_transfer.onshutdown_out_spec</code></a><br>
</div>


<pre><span id="TYPEonshutdown_in_spec"><span class="keyword">type</span> <code class="type"></code>onshutdown_in_spec</span> = <code class="type">[ `Action of<br>           <a href="Uq_engines.async_in_channel_engine-c.html">async_in_channel_engine</a> -><br>           <a href="Uq_engines.multiplex_controller-c.html">multiplex_controller</a> -> unit <a href="Uq_engines.html#TYPEengine_state">engine_state</a> -> unit<br>       | `Ignore<br>       | `Initiate_shutdown ]</code> </pre>
<div class="info ">
Moved to <a href="Uq_transfer.html#TYPEonshutdown_in_spec"><code class="code">Uq_transfer.onshutdown_in_spec</code></a><br>
</div>


<pre><span id="TYPEinetspec"><span class="keyword">type</span> <code class="type"></code>inetspec</span> = <code class="type">[ `Sock_inet of Unix.socket_type * Unix.inet_addr * int<br>       | `Sock_inet_byname of Unix.socket_type * string * int ]</code> </pre>
<div class="info ">
Moved to <a href="Uq_client.html#TYPEinetspec"><code class="code">Uq_client.inetspec</code></a><br>
</div>


<pre><span id="TYPEsockspec"><span class="keyword">type</span> <code class="type"></code>sockspec</span> = <code class="type">[ `Sock_inet of Unix.socket_type * Unix.inet_addr * int<br>       | `Sock_inet_byname of Unix.socket_type * string * int<br>       | `Sock_unix of Unix.socket_type * string ]</code> </pre>
<div class="info ">
Moved to <a href="Uq_client.html#TYPEsockspec"><code class="code">Uq_client.sockspec</code></a><br>
</div>


<pre><span id="TYPEconnect_address"><span class="keyword">type</span> <code class="type"></code>connect_address</span> = <code class="type">[ `Command of string * (int -> <a href="Unixqueue.event_system-c.html">Unixqueue.event_system</a> -> unit)<br>       | `Socket of <a href="Uq_engines.html#TYPEsockspec">sockspec</a> * <a href="Uq_engines.html#TYPEconnect_options">connect_options</a><br>       | `W32_pipe of <a href="Netsys_win32.html#TYPEpipe_mode">Netsys_win32.pipe_mode</a> * string ]</code> </pre>
<div class="info ">
Moved to <a href="Uq_client.html#TYPEconnect_address"><code class="code">Uq_client.connect_address</code></a><br>
</div>


<pre><code><span id="TYPEconnect_options"><span class="keyword">type</span> <code class="type"></code>connect_options</span> = {</code></pre><table class="typetable">
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTconnect_options.conn_bind">conn_bind</span>&nbsp;: <code class="type"><a href="Uq_engines.html#TYPEsockspec">sockspec</a> option</code>;</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
Bind the connecting socket to this address (same family as the
 connected socket required). <code class="code">None</code>: Use an anonymous port.<br>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr></table>
}



<pre><span id="TYPEconnect_status"><span class="keyword">type</span> <code class="type"></code>connect_status</span> = <code class="type">[ `Command of Unix.file_descr * int<br>       | `Socket of Unix.file_descr * <a href="Uq_engines.html#TYPEsockspec">sockspec</a><br>       | `W32_pipe of Unix.file_descr ]</code> </pre>
<div class="info ">
Moved to <a href="Uq_client.html#TYPEconnect_status"><code class="code">Uq_client.connect_status</code></a><br>
</div>


<pre><span id="TYPEclient_endpoint_connector"><span class="keyword">class type</span> <a href="Uq_engines.client_endpoint_connector-c.html">client_endpoint_connector</a></span> = <code class="code">object</code> <a href="Uq_engines.client_endpoint_connector-c.html">..</a> <code class="code">end</code></pre><div class="info">
Moved to <a href="Uq_client.client_endpoint_connector-c.html"><code class="code">Uq_client.client_endpoint_connector</code></a>
</div>

<pre><span id="TYPElisten_address"><span class="keyword">type</span> <code class="type"></code>listen_address</span> = <code class="type">[ `Socket of <a href="Uq_engines.html#TYPEsockspec">sockspec</a> * <a href="Uq_engines.html#TYPElisten_options">listen_options</a><br>       | `W32_pipe of <a href="Netsys_win32.html#TYPEpipe_mode">Netsys_win32.pipe_mode</a> * string * <a href="Uq_engines.html#TYPElisten_options">listen_options</a> ]</code> </pre>
<div class="info ">
Moved to <a href="Uq_server.html#TYPElisten_address"><code class="code">Uq_server.listen_address</code></a><br>
</div>


<pre><code><span id="TYPElisten_options"><span class="keyword">type</span> <code class="type"></code>listen_options</span> = {</code></pre><table class="typetable">
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTlisten_options.lstn_backlog">lstn_backlog</span>&nbsp;: <code class="type">int</code>;</code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTlisten_options.lstn_reuseaddr">lstn_reuseaddr</span>&nbsp;: <code class="type">bool</code>;</code></td>

</tr></table>
}



<pre><span id="TYPEserver_endpoint_acceptor"><span class="keyword">class type</span> <a href="Uq_engines.server_endpoint_acceptor-c.html">server_endpoint_acceptor</a></span> = <code class="code">object</code> <a href="Uq_engines.server_endpoint_acceptor-c.html">..</a> <code class="code">end</code></pre><div class="info">
Moved to <a href="Uq_server.server_endpoint_acceptor-c.html"><code class="code">Uq_server.server_endpoint_acceptor</code></a>
</div>

<pre><span id="TYPEserver_endpoint_listener"><span class="keyword">class type</span> <a href="Uq_engines.server_endpoint_listener-c.html">server_endpoint_listener</a></span> = <code class="code">object</code> <a href="Uq_engines.server_endpoint_listener-c.html">..</a> <code class="code">end</code></pre><div class="info">
Moved to <code class="code">Uq_server.server_endpoint_listener</code>
</div>

<pre><span id="TYPEdatagram_type"><span class="keyword">type</span> <code class="type"></code>datagram_type</span> = <code class="type">[ `Inet6_udp | `Inet_udp | `Unix_dgram ]</code> </pre>
<div class="info ">
Moved to <a href="Uq_datagram.html#TYPEdatagram_type"><code class="code">Uq_datagram.datagram_type</code></a><br>
</div>


<pre><span id="TYPEwrapped_datagram_socket"><span class="keyword">class type</span> <a href="Uq_engines.wrapped_datagram_socket-c.html">wrapped_datagram_socket</a></span> = <code class="code">object</code> <a href="Uq_engines.wrapped_datagram_socket-c.html">..</a> <code class="code">end</code></pre><div class="info">
Moved to <a href="Uq_datagram.html#TYPEdatagram_type"><code class="code">Uq_datagram.datagram_type</code></a>
</div>

<pre><span id="TYPEdatagram_socket_provider"><span class="keyword">class type</span> <a href="Uq_engines.datagram_socket_provider-c.html">datagram_socket_provider</a></span> = <code class="code">object</code> <a href="Uq_engines.datagram_socket_provider-c.html">..</a> <code class="code">end</code></pre><div class="info">
Moved to <a href="Uq_datagram.html#TYPEdatagram_type"><code class="code">Uq_datagram.datagram_type</code></a>
</div>
<br>
<h1 id="1_Debugging">Debugging</h1><br>

<pre><span class="keyword">module</span> <a href="Uq_engines.Debug.html">Debug</a>: <code class="code">sig</code> <a href="Uq_engines.Debug.html">..</a> <code class="code">end</code></pre></body></html>