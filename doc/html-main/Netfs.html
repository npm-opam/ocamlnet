<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<link rel="stylesheet" href="style.css" type="text/css">
<meta content="text/html; charset=iso-8859-1" http-equiv="Content-Type">
<link rel="Start" href="index.html">
<link rel="previous" href="Netpagebuffer.html">
<link rel="next" href="Netglob.html">
<link rel="Up" href="index.html">
<link title="Index of types" rel=Appendix href="index_types.html">
<link title="Index of extensions" rel=Appendix href="index_extensions.html">
<link title="Index of exceptions" rel=Appendix href="index_exceptions.html">
<link title="Index of values" rel=Appendix href="index_values.html">
<link title="Index of class attributes" rel=Appendix href="index_attributes.html">
<link title="Index of class methods" rel=Appendix href="index_methods.html">
<link title="Index of classes" rel=Appendix href="index_classes.html">
<link title="Index of class types" rel=Appendix href="index_class_types.html">
<link title="Index of modules" rel=Appendix href="index_modules.html">
<link title="Index of module types" rel=Appendix href="index_module_types.html">
<link title="Uq_gtk" rel="Chapter" href="Uq_gtk.html">
<link title="Uq_tcl" rel="Chapter" href="Uq_tcl.html">
<link title="Equeue" rel="Chapter" href="Equeue.html">
<link title="Unixqueue" rel="Chapter" href="Unixqueue.html">
<link title="Unixqueue_pollset" rel="Chapter" href="Unixqueue_pollset.html">
<link title="Unixqueue_select" rel="Chapter" href="Unixqueue_select.html">
<link title="Uq_resolver" rel="Chapter" href="Uq_resolver.html">
<link title="Uq_engines" rel="Chapter" href="Uq_engines.html">
<link title="Uq_multiplex" rel="Chapter" href="Uq_multiplex.html">
<link title="Uq_transfer" rel="Chapter" href="Uq_transfer.html">
<link title="Uq_socks5" rel="Chapter" href="Uq_socks5.html">
<link title="Uq_io" rel="Chapter" href="Uq_io.html">
<link title="Uq_lwt" rel="Chapter" href="Uq_lwt.html">
<link title="Uq_libevent" rel="Chapter" href="Uq_libevent.html">
<link title="Uq_mt" rel="Chapter" href="Uq_mt.html">
<link title="Uq_client" rel="Chapter" href="Uq_client.html">
<link title="Uq_server" rel="Chapter" href="Uq_server.html">
<link title="Uq_datagram" rel="Chapter" href="Uq_datagram.html">
<link title="Uq_engines_compat" rel="Chapter" href="Uq_engines_compat.html">
<link title="Equeue_intro" rel="Chapter" href="Equeue_intro.html">
<link title="Equeue_howto" rel="Chapter" href="Equeue_howto.html">
<link title="Netcamlbox" rel="Chapter" href="Netcamlbox.html">
<link title="Netcgi_apache" rel="Chapter" href="Netcgi_apache.html">
<link title="Netcgi_modtpl" rel="Chapter" href="Netcgi_modtpl.html">
<link title="Netcgi_plex" rel="Chapter" href="Netcgi_plex.html">
<link title="Netcgi_common" rel="Chapter" href="Netcgi_common.html">
<link title="Netcgi" rel="Chapter" href="Netcgi.html">
<link title="Netcgi_ajp" rel="Chapter" href="Netcgi_ajp.html">
<link title="Netcgi_scgi" rel="Chapter" href="Netcgi_scgi.html">
<link title="Netcgi_cgi" rel="Chapter" href="Netcgi_cgi.html">
<link title="Netcgi_fcgi" rel="Chapter" href="Netcgi_fcgi.html">
<link title="Netcgi_dbi" rel="Chapter" href="Netcgi_dbi.html">
<link title="Netcgi1_compat" rel="Chapter" href="Netcgi1_compat.html">
<link title="Netcgi_test" rel="Chapter" href="Netcgi_test.html">
<link title="Netcgi_porting" rel="Chapter" href="Netcgi_porting.html">
<link title="Nethttp_client_conncache" rel="Chapter" href="Nethttp_client_conncache.html">
<link title="Nethttp_client" rel="Chapter" href="Nethttp_client.html">
<link title="Nettelnet_client" rel="Chapter" href="Nettelnet_client.html">
<link title="Netftp_data_endpoint" rel="Chapter" href="Netftp_data_endpoint.html">
<link title="Netftp_client" rel="Chapter" href="Netftp_client.html">
<link title="Nethttp_fs" rel="Chapter" href="Nethttp_fs.html">
<link title="Netftp_fs" rel="Chapter" href="Netftp_fs.html">
<link title="Netsmtp" rel="Chapter" href="Netsmtp.html">
<link title="Netpop" rel="Chapter" href="Netpop.html">
<link title="Netldap" rel="Chapter" href="Netldap.html">
<link title="Netclient_tut" rel="Chapter" href="Netclient_tut.html">
<link title="Netgss_bindings" rel="Chapter" href="Netgss_bindings.html">
<link title="Netgss" rel="Chapter" href="Netgss.html">
<link title="Nethttpd_types" rel="Chapter" href="Nethttpd_types.html">
<link title="Nethttpd_kernel" rel="Chapter" href="Nethttpd_kernel.html">
<link title="Nethttpd_reactor" rel="Chapter" href="Nethttpd_reactor.html">
<link title="Nethttpd_engine" rel="Chapter" href="Nethttpd_engine.html">
<link title="Nethttpd_services" rel="Chapter" href="Nethttpd_services.html">
<link title="Nethttpd_plex" rel="Chapter" href="Nethttpd_plex.html">
<link title="Nethttpd_util" rel="Chapter" href="Nethttpd_util.html">
<link title="Nethttpd_intro" rel="Chapter" href="Nethttpd_intro.html">
<link title="Netmcore" rel="Chapter" href="Netmcore.html">
<link title="Netmcore_camlbox" rel="Chapter" href="Netmcore_camlbox.html">
<link title="Netmcore_mempool" rel="Chapter" href="Netmcore_mempool.html">
<link title="Netmcore_heap" rel="Chapter" href="Netmcore_heap.html">
<link title="Netmcore_ref" rel="Chapter" href="Netmcore_ref.html">
<link title="Netmcore_array" rel="Chapter" href="Netmcore_array.html">
<link title="Netmcore_sem" rel="Chapter" href="Netmcore_sem.html">
<link title="Netmcore_mutex" rel="Chapter" href="Netmcore_mutex.html">
<link title="Netmcore_condition" rel="Chapter" href="Netmcore_condition.html">
<link title="Netmcore_queue" rel="Chapter" href="Netmcore_queue.html">
<link title="Netmcore_buffer" rel="Chapter" href="Netmcore_buffer.html">
<link title="Netmcore_matrix" rel="Chapter" href="Netmcore_matrix.html">
<link title="Netmcore_hashtbl" rel="Chapter" href="Netmcore_hashtbl.html">
<link title="Netmcore_process" rel="Chapter" href="Netmcore_process.html">
<link title="Netmcore_tut" rel="Chapter" href="Netmcore_tut.html">
<link title="Netmcore_basics" rel="Chapter" href="Netmcore_basics.html">
<link title="Netplex_types" rel="Chapter" href="Netplex_types.html">
<link title="Netplex_mp" rel="Chapter" href="Netplex_mp.html">
<link title="Netplex_mt" rel="Chapter" href="Netplex_mt.html">
<link title="Netplex_log" rel="Chapter" href="Netplex_log.html">
<link title="Netplex_controller" rel="Chapter" href="Netplex_controller.html">
<link title="Netplex_container" rel="Chapter" href="Netplex_container.html">
<link title="Netplex_sockserv" rel="Chapter" href="Netplex_sockserv.html">
<link title="Netplex_workload" rel="Chapter" href="Netplex_workload.html">
<link title="Netplex_main" rel="Chapter" href="Netplex_main.html">
<link title="Netplex_config" rel="Chapter" href="Netplex_config.html">
<link title="Netplex_kit" rel="Chapter" href="Netplex_kit.html">
<link title="Rpc_netplex" rel="Chapter" href="Rpc_netplex.html">
<link title="Netplex_cenv" rel="Chapter" href="Netplex_cenv.html">
<link title="Netplex_semaphore" rel="Chapter" href="Netplex_semaphore.html">
<link title="Netplex_sharedvar" rel="Chapter" href="Netplex_sharedvar.html">
<link title="Netplex_mutex" rel="Chapter" href="Netplex_mutex.html">
<link title="Netplex_encap" rel="Chapter" href="Netplex_encap.html">
<link title="Netplex_mbox" rel="Chapter" href="Netplex_mbox.html">
<link title="Netplex_internal" rel="Chapter" href="Netplex_internal.html">
<link title="Netplex_intro" rel="Chapter" href="Netplex_intro.html">
<link title="Netplex_advanced" rel="Chapter" href="Netplex_advanced.html">
<link title="Netplex_admin" rel="Chapter" href="Netplex_admin.html">
<link title="Netshm" rel="Chapter" href="Netshm.html">
<link title="Netshm_data" rel="Chapter" href="Netshm_data.html">
<link title="Netshm_hashtbl" rel="Chapter" href="Netshm_hashtbl.html">
<link title="Netshm_array" rel="Chapter" href="Netshm_array.html">
<link title="Netshm_intro" rel="Chapter" href="Netshm_intro.html">
<link title="Netstring_pcre" rel="Chapter" href="Netstring_pcre.html">
<link title="Netconversion" rel="Chapter" href="Netconversion.html">
<link title="Netchannels" rel="Chapter" href="Netchannels.html">
<link title="Netstream" rel="Chapter" href="Netstream.html">
<link title="Netmime_string" rel="Chapter" href="Netmime_string.html">
<link title="Netmime" rel="Chapter" href="Netmime.html">
<link title="Netsendmail" rel="Chapter" href="Netsendmail.html">
<link title="Neturl" rel="Chapter" href="Neturl.html">
<link title="Netaddress" rel="Chapter" href="Netaddress.html">
<link title="Netbuffer" rel="Chapter" href="Netbuffer.html">
<link title="Netmime_header" rel="Chapter" href="Netmime_header.html">
<link title="Netmime_channels" rel="Chapter" href="Netmime_channels.html">
<link title="Neturl_ldap" rel="Chapter" href="Neturl_ldap.html">
<link title="Netdate" rel="Chapter" href="Netdate.html">
<link title="Netencoding" rel="Chapter" href="Netencoding.html">
<link title="Netulex" rel="Chapter" href="Netulex.html">
<link title="Netaccel" rel="Chapter" href="Netaccel.html">
<link title="Netaccel_link" rel="Chapter" href="Netaccel_link.html">
<link title="Nethtml" rel="Chapter" href="Nethtml.html">
<link title="Netstring_str" rel="Chapter" href="Netstring_str.html">
<link title="Netmappings" rel="Chapter" href="Netmappings.html">
<link title="Netaux" rel="Chapter" href="Netaux.html">
<link title="Nethttp" rel="Chapter" href="Nethttp.html">
<link title="Netpagebuffer" rel="Chapter" href="Netpagebuffer.html">
<link title="Netfs" rel="Chapter" href="Netfs.html">
<link title="Netglob" rel="Chapter" href="Netglob.html">
<link title="Netauth" rel="Chapter" href="Netauth.html">
<link title="Netsockaddr" rel="Chapter" href="Netsockaddr.html">
<link title="Netnumber" rel="Chapter" href="Netnumber.html">
<link title="Netxdr_mstring" rel="Chapter" href="Netxdr_mstring.html">
<link title="Netxdr" rel="Chapter" href="Netxdr.html">
<link title="Netcompression" rel="Chapter" href="Netcompression.html">
<link title="Netunichar" rel="Chapter" href="Netunichar.html">
<link title="Netasn1" rel="Chapter" href="Netasn1.html">
<link title="Netasn1_encode" rel="Chapter" href="Netasn1_encode.html">
<link title="Netoid" rel="Chapter" href="Netoid.html">
<link title="Netstring_tstring" rel="Chapter" href="Netstring_tstring.html">
<link title="Netdn" rel="Chapter" href="Netdn.html">
<link title="Netx509" rel="Chapter" href="Netx509.html">
<link title="Netascii_armor" rel="Chapter" href="Netascii_armor.html">
<link title="Nettls_support" rel="Chapter" href="Nettls_support.html">
<link title="Netmech_scram" rel="Chapter" href="Netmech_scram.html">
<link title="Netmech_scram_gssapi" rel="Chapter" href="Netmech_scram_gssapi.html">
<link title="Netmech_scram_sasl" rel="Chapter" href="Netmech_scram_sasl.html">
<link title="Netmech_scram_http" rel="Chapter" href="Netmech_scram_http.html">
<link title="Netgssapi_support" rel="Chapter" href="Netgssapi_support.html">
<link title="Netgssapi_auth" rel="Chapter" href="Netgssapi_auth.html">
<link title="Netchannels_crypto" rel="Chapter" href="Netchannels_crypto.html">
<link title="Netx509_pubkey" rel="Chapter" href="Netx509_pubkey.html">
<link title="Netx509_pubkey_crypto" rel="Chapter" href="Netx509_pubkey_crypto.html">
<link title="Netsaslprep" rel="Chapter" href="Netsaslprep.html">
<link title="Netmech_plain_sasl" rel="Chapter" href="Netmech_plain_sasl.html">
<link title="Netmech_crammd5_sasl" rel="Chapter" href="Netmech_crammd5_sasl.html">
<link title="Netmech_digest_sasl" rel="Chapter" href="Netmech_digest_sasl.html">
<link title="Netmech_digest_http" rel="Chapter" href="Netmech_digest_http.html">
<link title="Netmech_krb5_sasl" rel="Chapter" href="Netmech_krb5_sasl.html">
<link title="Netmech_gs2_sasl" rel="Chapter" href="Netmech_gs2_sasl.html">
<link title="Netmech_spnego_http" rel="Chapter" href="Netmech_spnego_http.html">
<link title="Netchannels_tut" rel="Chapter" href="Netchannels_tut.html">
<link title="Netmime_tut" rel="Chapter" href="Netmime_tut.html">
<link title="Netsendmail_tut" rel="Chapter" href="Netsendmail_tut.html">
<link title="Netulex_tut" rel="Chapter" href="Netulex_tut.html">
<link title="Neturl_tut" rel="Chapter" href="Neturl_tut.html">
<link title="Netsys" rel="Chapter" href="Netsys.html">
<link title="Netsys_posix" rel="Chapter" href="Netsys_posix.html">
<link title="Netsys_pollset" rel="Chapter" href="Netsys_pollset.html">
<link title="Netlog" rel="Chapter" href="Netlog.html">
<link title="Netexn" rel="Chapter" href="Netexn.html">
<link title="Netsys_win32" rel="Chapter" href="Netsys_win32.html">
<link title="Netsys_pollset_posix" rel="Chapter" href="Netsys_pollset_posix.html">
<link title="Netsys_pollset_win32" rel="Chapter" href="Netsys_pollset_win32.html">
<link title="Netsys_pollset_generic" rel="Chapter" href="Netsys_pollset_generic.html">
<link title="Netsys_signal" rel="Chapter" href="Netsys_signal.html">
<link title="Netsys_oothr" rel="Chapter" href="Netsys_oothr.html">
<link title="Netsys_xdr" rel="Chapter" href="Netsys_xdr.html">
<link title="Netsys_rng" rel="Chapter" href="Netsys_rng.html">
<link title="Netsys_crypto_types" rel="Chapter" href="Netsys_crypto_types.html">
<link title="Netsys_types" rel="Chapter" href="Netsys_types.html">
<link title="Netsys_mem" rel="Chapter" href="Netsys_mem.html">
<link title="Netsys_tmp" rel="Chapter" href="Netsys_tmp.html">
<link title="Netsys_sem" rel="Chapter" href="Netsys_sem.html">
<link title="Netsys_pmanage" rel="Chapter" href="Netsys_pmanage.html">
<link title="Netsys_crypto" rel="Chapter" href="Netsys_crypto.html">
<link title="Netsys_tls" rel="Chapter" href="Netsys_tls.html">
<link title="Netsys_ciphers" rel="Chapter" href="Netsys_ciphers.html">
<link title="Netsys_digests" rel="Chapter" href="Netsys_digests.html">
<link title="Netsys_crypto_modes" rel="Chapter" href="Netsys_crypto_modes.html">
<link title="Netsys_gssapi" rel="Chapter" href="Netsys_gssapi.html">
<link title="Netsys_sasl_types" rel="Chapter" href="Netsys_sasl_types.html">
<link title="Netsys_sasl" rel="Chapter" href="Netsys_sasl.html">
<link title="Netsys_polypipe" rel="Chapter" href="Netsys_polypipe.html">
<link title="Netsys_polysocket" rel="Chapter" href="Netsys_polysocket.html">
<link title="Netsys_global" rel="Chapter" href="Netsys_global.html">
<link title="Nettls_gnutls_bindings" rel="Chapter" href="Nettls_gnutls_bindings.html">
<link title="Nettls_nettle_bindings" rel="Chapter" href="Nettls_nettle_bindings.html">
<link title="Nettls_gnutls" rel="Chapter" href="Nettls_gnutls.html">
<link title="Netunidata" rel="Chapter" href="Netunidata.html">
<link title="Netgzip" rel="Chapter" href="Netgzip.html">
<link title="Rpc_auth_local" rel="Chapter" href="Rpc_auth_local.html">
<link title="Rpc_xti_client" rel="Chapter" href="Rpc_xti_client.html">
<link title="Rpc" rel="Chapter" href="Rpc.html">
<link title="Rpc_program" rel="Chapter" href="Rpc_program.html">
<link title="Rpc_util" rel="Chapter" href="Rpc_util.html">
<link title="Rpc_portmapper_aux" rel="Chapter" href="Rpc_portmapper_aux.html">
<link title="Rpc_packer" rel="Chapter" href="Rpc_packer.html">
<link title="Rpc_transport" rel="Chapter" href="Rpc_transport.html">
<link title="Rpc_client" rel="Chapter" href="Rpc_client.html">
<link title="Rpc_simple_client" rel="Chapter" href="Rpc_simple_client.html">
<link title="Rpc_portmapper_clnt" rel="Chapter" href="Rpc_portmapper_clnt.html">
<link title="Rpc_portmapper" rel="Chapter" href="Rpc_portmapper.html">
<link title="Rpc_server" rel="Chapter" href="Rpc_server.html">
<link title="Rpc_auth_sys" rel="Chapter" href="Rpc_auth_sys.html">
<link title="Rpc_auth_gssapi" rel="Chapter" href="Rpc_auth_gssapi.html">
<link title="Rpc_proxy" rel="Chapter" href="Rpc_proxy.html">
<link title="Rpc_intro" rel="Chapter" href="Rpc_intro.html">
<link title="Rpc_mapping_ref" rel="Chapter" href="Rpc_mapping_ref.html">
<link title="Rpc_intro_gss" rel="Chapter" href="Rpc_intro_gss.html">
<link title="Shell_sys" rel="Chapter" href="Shell_sys.html">
<link title="Shell" rel="Chapter" href="Shell.html">
<link title="Shell_uq" rel="Chapter" href="Shell_uq.html">
<link title="Shell_fs" rel="Chapter" href="Shell_fs.html">
<link title="Shell_intro" rel="Chapter" href="Shell_intro.html">
<link title="Intro" rel="Chapter" href="Intro.html">
<link title="Platform" rel="Chapter" href="Platform.html">
<link title="Foreword" rel="Chapter" href="Foreword.html">
<link title="Ipv6" rel="Chapter" href="Ipv6.html">
<link title="Regexp" rel="Chapter" href="Regexp.html">
<link title="Tls" rel="Chapter" href="Tls.html">
<link title="Crypto" rel="Chapter" href="Crypto.html">
<link title="Authentication" rel="Chapter" href="Authentication.html">
<link title="Credentials" rel="Chapter" href="Credentials.html">
<link title="Gssapi" rel="Chapter" href="Gssapi.html">
<link title="Ocamlnet4" rel="Chapter" href="Ocamlnet4.html">
<link title="Get" rel="Chapter" href="Get.html"><link title="The class type stream_fs" rel="Section" href="#2_Theclasstypestreamfs">
<link title="OS Notes" rel="Section" href="#2_OSNotes">
<link title="OS Notes" rel="Section" href="#2_OSNotes">
<link title="OS Notes" rel="Section" href="#2_OSNotes">
<link title="OS Notes" rel="Section" href="#2_OSNotes">
<link title="Other impementations of stream_fs" rel="Section" href="#links">
<link title="OS Notes" rel="Section" href="#2_OSNotes">
<link title="Other impementations of stream_fs" rel="Section" href="#links">
<link title="OS Notes" rel="Section" href="#2_OSNotes">
<link title="Other impementations of stream_fs" rel="Section" href="#links">
<link title="Algorithms" rel="Section" href="#2_Algorithms">
<title>Ocamlnet 4 Reference Manual : Netfs</title>
</head>
<body>
<div class="navbar"><a class="pre" href="Netpagebuffer.html" title="Netpagebuffer">Previous</a>
&nbsp;<a class="up" href="index.html" title="Index">Up</a>
&nbsp;<a class="post" href="Netglob.html" title="Netglob">Next</a>
</div>
<h1>Module <a href="type_Netfs.html">Netfs</a></h1>

<pre><span class="keyword">module</span> Netfs: <code class="code">sig</code> <a href="Netfs.html">..</a> <code class="code">end</code></pre><div class="info module top">
Class type <code class="code">stream_fs</code> for filesystems with stream access to files<br>
</div>
<hr width="100%">
<br>
The class type <a href="Netfs.stream_fs-c.html"><code class="code">Netfs.stream_fs</code></a>
    is an abstraction for both kernel-level and user-level
    filesystems. It is used as parameter for algorithms (like globbing)
    that operate on filesystems but do not want to assume any particular
    filesystem. Only stream access is provided (no seek).
<p>

    <b>File paths:</b>
<p>

    The filesystem supports hierarchical file names. File paths use
    Unix conventions, i.e.<ul>
<li><code class="code">/</code> is the root</li>
<li>Path components are separated by slashes. Several consecutive slashes
      are allowed but mean the same as a single slash.</li>
<li><code class="code">.</code> is the same directory</li>
<li><code class="code">..</code> is the parent directory</li>
</ul>

    All paths need to be absolute (i.e. start with <code class="code">/</code>).
<p>

    There can be additional constraints on paths:<ul>
<li>Character encoding restriction: A certain ASCII-compatible character
      encoding is assumed (including UTF-8)  </li>
<li>Character exclusion: Certain characters may be excluded</li>
</ul>

    Implementations may impose more constraints that cannot be expressed
    here (case insensitivity, path length, exclusion of special names etc.).
<p>

    <b>Virtuality:</b>
<p>

    There is no assumption that <code class="code">/</code> is the real root of the local filesystem.
    It can actually be anywhere - a local subdirectory, or a remote directory,
    or a fictive root. There needs not to be any protection against "running
    beyond root", e.g. with the path <code class="code">/..</code>.
<p>

    This class type also supports remote filesystems, and thus there is no
    concept of file handle (because this would exclude a number of
    implementations).
<p>

    <b>Errors: </b>
<p>

    Errors should generally be indicated by raising <code class="code">Unix_error</code>. For
    many error codes the interpretation is already given by POSIX. Here
    are some more special cases:<ul>
<li><code class="code">EINVAL</code>: should also be used for invalid paths, or when a flag
      cannot be supported (and it is non-ignorable)</li>
<li><code class="code">ENOSYS</code>: should also be used if an operation is generally unavailable</li>
</ul>

    In case of hard errors (like socket errors when communicating with the
    remote server) there is no need to stick to <code class="code">Unix_error</code>, though.
<p>

    <b>Subtyping:</b>
<p>

    The class type <a href="Netfs.stream_fs-c.html"><code class="code">Netfs.stream_fs</code></a> is subtypable, and subtypes can add
    more features by:<ul>
<li>adding more methods</li>
<li>adding more flags to existing methods</li>
</ul>

    <b>Omitted:</b>
<p>

    Real filesystems usually provide a lot more features than what is
    represented here, such as:<ul>
<li>Access control and file permissions</li>
<li>Metadata like timestamps</li>
<li>Random access to files</li>
</ul>

    This definition here is intentionally minimalistic. In the future
    this class type will be extended, and more more common filesystem features
    will be covered. See <a href="Netfs.empty_fs-c.html"><code class="code">Netfs.empty_fs</code></a> for a way how to ensure that
    your definition of a <code class="code">stream_fs</code> can still be built after <code class="code">stream_fs</code>
    has been extended.<br>
<br>
The class type <a href="Netfs.stream_fs-c.html"><code class="code">Netfs.stream_fs</code></a>
    is an abstraction for both kernel-level and user-level
    filesystems. It is used as parameter for algorithms (like globbing)
    that operate on filesystems but do not want to assume any particular
    filesystem. Only stream access is provided (no seek).
<p>

    <b>File paths:</b>
<p>

    The filesystem supports hierarchical file names. File paths use
    Unix conventions, i.e.<ul>
<li><code class="code">/</code> is the root</li>
<li>Path components are separated by slashes. Several consecutive slashes
      are allowed but mean the same as a single slash.</li>
<li><code class="code">.</code> is the same directory</li>
<li><code class="code">..</code> is the parent directory</li>
</ul>

    All paths need to be absolute (i.e. start with <code class="code">/</code>).
<p>

    There can be additional constraints on paths:<ul>
<li>Character encoding restriction: A certain ASCII-compatible character
      encoding is assumed (including UTF-8)  </li>
<li>Character exclusion: Certain characters may be excluded</li>
</ul>

    Implementations may impose more constraints that cannot be expressed
    here (case insensitivity, path length, exclusion of special names etc.).
<p>

    <b>Virtuality:</b>
<p>

    There is no assumption that <code class="code">/</code> is the real root of the local filesystem.
    It can actually be anywhere - a local subdirectory, or a remote directory,
    or a fictive root. There needs not to be any protection against "running
    beyond root", e.g. with the path <code class="code">/..</code>.
<p>

    This class type also supports remote filesystems, and thus there is no
    concept of file handle (because this would exclude a number of
    implementations).
<p>

    <b>Errors: </b>
<p>

    Errors should generally be indicated by raising <code class="code">Unix_error</code>. For
    many error codes the interpretation is already given by POSIX. Here
    are some more special cases:<ul>
<li><code class="code">EINVAL</code>: should also be used for invalid paths, or when a flag
      cannot be supported (and it is non-ignorable)</li>
<li><code class="code">ENOSYS</code>: should also be used if an operation is generally unavailable</li>
</ul>

    In case of hard errors (like socket errors when communicating with the
    remote server) there is no need to stick to <code class="code">Unix_error</code>, though.
<p>

    <b>Subtyping:</b>
<p>

    The class type <a href="Netfs.stream_fs-c.html"><code class="code">Netfs.stream_fs</code></a> is subtypable, and subtypes can add
    more features by:<ul>
<li>adding more methods</li>
<li>adding more flags to existing methods</li>
</ul>

    <b>Omitted:</b>
<p>

    Real filesystems usually provide a lot more features than what is
    represented here, such as:<ul>
<li>Access control and file permissions</li>
<li>Metadata like timestamps</li>
<li>Random access to files</li>
</ul>

    This definition here is intentionally minimalistic. In the future
    this class type will be extended, and more more common filesystem features
    will be covered. See <a href="Netfs.empty_fs-c.html"><code class="code">Netfs.empty_fs</code></a> for a way how to ensure that
    your definition of a <code class="code">stream_fs</code> can still be built after <code class="code">stream_fs</code>
    has been extended.<br>
<br>
<h2 id="2_Theclasstypestreamfs">The class type <code class="code">stream_fs</code></h2><br>

<pre><span id="TYPEread_flag"><span class="keyword">type</span> <code class="type"></code>read_flag</span> = <code class="type">[ `Binary | `Dummy | `Skip of int64 | `Streaming ]</code> </pre>


<pre><span id="TYPEread_file_flag"><span class="keyword">type</span> <code class="type"></code>read_file_flag</span> = <code class="type">[ `Binary | `Dummy ]</code> </pre>


<pre><span id="TYPEwrite_flag"><span class="keyword">type</span> <code class="type"></code>write_flag</span> = <code class="type">[ `Binary | `Create | `Dummy | `Exclusive | `Streaming | `Truncate ]</code> </pre>


<pre><span id="TYPEwrite_file_flag"><span class="keyword">type</span> <code class="type"></code>write_file_flag</span> = <code class="type">[ `Binary | `Create | `Dummy | `Exclusive | `Link | `Truncate ]</code> </pre>


<pre><span id="TYPEwrite_common"><span class="keyword">type</span> <code class="type"></code>write_common</span> = <code class="type">[ `Binary | `Create | `Dummy | `Exclusive | `Truncate ]</code> </pre>
<div class="info ">
The intersection of <code class="code">write_flag</code> and <code class="code">write_file_flag</code><br>
</div>


<pre><span id="TYPEsize_flag"><span class="keyword">type</span> <code class="type"></code>size_flag</span> = <code class="type">[ `Dummy ]</code> </pre>


<pre><span id="TYPEtest_flag"><span class="keyword">type</span> <code class="type"></code>test_flag</span> = <code class="type">[ `Dummy | `Link ]</code> </pre>


<pre><span id="TYPEremove_flag"><span class="keyword">type</span> <code class="type"></code>remove_flag</span> = <code class="type">[ `Dummy | `Recursive ]</code> </pre>


<pre><span id="TYPErename_flag"><span class="keyword">type</span> <code class="type"></code>rename_flag</span> = <code class="type">[ `Dummy ]</code> </pre>


<pre><span id="TYPEsymlink_flag"><span class="keyword">type</span> <code class="type"></code>symlink_flag</span> = <code class="type">[ `Dummy ]</code> </pre>


<pre><span id="TYPEreaddir_flag"><span class="keyword">type</span> <code class="type"></code>readdir_flag</span> = <code class="type">[ `Dummy ]</code> </pre>


<pre><span id="TYPEreadlink_flag"><span class="keyword">type</span> <code class="type"></code>readlink_flag</span> = <code class="type">[ `Dummy ]</code> </pre>


<pre><span id="TYPEmkdir_flag"><span class="keyword">type</span> <code class="type"></code>mkdir_flag</span> = <code class="type">[ `Dummy | `Nonexcl | `Path ]</code> </pre>


<pre><span id="TYPErmdir_flag"><span class="keyword">type</span> <code class="type"></code>rmdir_flag</span> = <code class="type">[ `Dummy ]</code> </pre>


<pre><span id="TYPEcopy_flag"><span class="keyword">type</span> <code class="type"></code>copy_flag</span> = <code class="type">[ `Dummy ]</code> </pre>

<br>
Note <code class="code">`Dummy</code>: this flag is always ignored. There are two reasons
    for having it:<ul>
<li>Ocaml does not allow empty variants</li>
<li>it is sometimes convenient to have it
      (e.g. in: <code class="code">if &lt;condition&gt; then `Create else `Dummy</code>)</li>
</ul>
<br>

<pre><span id="TYPEtest_type"><span class="keyword">type</span> <code class="type"></code>test_type</span> = <code class="type">[ `D | `E | `F | `H | `N | `R | `S | `W | `X ]</code> </pre>
<div class="info ">
Tests:<ul>
<li><code class="code">`N</code>: the file name exists</li>
<li><code class="code">`E</code>: the file exists</li>
<li><code class="code">`D</code>: the file exists and is a directory</li>
<li><code class="code">`F</code>: the file exists and is regular</li>
<li><code class="code">`H</code>: the file exists and is a symlink (possibly to a non-existing
           target)</li>
<li><code class="code">`R</code>: the file exists and is readable</li>
<li><code class="code">`W</code>: the file exists and is writable</li>
<li><code class="code">`X</code>: the file exists and is executable</li>
<li><code class="code">`S</code>: the file exists and is non-empty</li>
</ul>
<br>
</div>


<pre><span id="TYPElocal_file"><span class="keyword">class type</span> <a href="Netfs.local_file-c.html">local_file</a></span> = <code class="code">object</code> <a href="Netfs.local_file-c.html">..</a> <code class="code">end</code></pre>
<pre><span id="TYPEstream_fs"><span class="keyword">class type</span> <a href="Netfs.stream_fs-c.html">stream_fs</a></span> = <code class="code">object</code> <a href="Netfs.stream_fs-c.html">..</a> <code class="code">end</code></pre>
<pre><span name="TYPEempty_fs"><span class="keyword">class</span> <a href="Netfs.empty_fs-c.html">empty_fs</a></span> : <code class="type">string -> </code><code class="type"><a href="Netfs.stream_fs-c.html">stream_fs</a></code></pre><div class="info">
This is a class where all methods fail with <code class="code">ENOSYS</code>.
</div>

<pre><span id="VALlocal_fs"><span class="keyword">val</span> local_fs</span> : <code class="type">?encoding:<a href="Netconversion.html#TYPEencoding">Netconversion.encoding</a> -><br>       ?root:string -> ?enable_relative_paths:bool -> unit -> <a href="Netfs.stream_fs-c.html">stream_fs</a></code></pre><div class="info ">
<code class="code">local_fs()</code>: Returns a filesystem object for the local filesystem.
<p>
<ul>
<li><code class="code">encoding</code>: Specifies the character encoding of paths. The default
        is system-dependent.</li>
<li><code class="code">root</code>: the root of the returned object is the directory <code class="code">root</code>
        of the local filesystem. If omitted, the root is the root of
        the local filesystem (i.e. / for Unix, and see comments for
        Windows below). Use <code class="code">root="."</code> to make the current working
        directory the root. Note that "." like other relative paths
        are interpreted at the time when the access method is executed.</li>
<li><code class="code">enable_relative_paths</code>: Normally, only absolute paths can be
        passed to the access methods like <code class="code">read</code>. By setting this option
        to <code class="code">true</code> one can also enable relative paths. These are taken
        relative to the working directory, and not relative to <code class="code">root</code>.
        Relative names are off by default because there is usually no
        counterpart in network filesystems.</li>
</ul>
<br>
</div>
<br>
<h2 id="2_OSNotes">OS Notes</h2><br>
<br>
<h2 id="2_OSNotes">OS Notes</h2><br>
<br>
<b>Unix</b> in general: There is no notion of character encoding of
    paths. Paths are just bytes. Because of this, the default encoding
    is <code class="code">None</code>. If a different encoding is passed to <code class="code">local_fs</code>, these
    bytes are just interpreted in this encoding. There is no conversion.
<p>

    For desktop programs, though, usually the character encoding of the
    locale is taken for filenames. You can get this by passing
<p>

    <pre class="codepre"><code class="code">    let encoding = 
      Netconversion.user_encoding()
    </code></pre>
<p>

    as <code class="code">encoding</code> argument.<br>
<br>
<h2 id="2_OSNotes">OS Notes</h2><br>
<br>
<b>Unix</b> in general: There is no notion of character encoding of
    paths. Paths are just bytes. Because of this, the default encoding
    is <code class="code">None</code>. If a different encoding is passed to <code class="code">local_fs</code>, these
    bytes are just interpreted in this encoding. There is no conversion.
<p>

    For desktop programs, though, usually the character encoding of the
    locale is taken for filenames. You can get this by passing
<p>

    <pre class="codepre"><code class="code">    let encoding = 
      Netconversion.user_encoding()
    </code></pre>
<p>

    as <code class="code">encoding</code> argument.<br>
<br>
<b>Windows</b>: If the <code class="code">root</code> argument is <b>not</b> passed to <code class="code">local_fs</code>
    it is possible to access the whole filesystem:
<p>
<ul>
<li>Paths starting with drive letters like <code class="code">c:/</code> are also considered
      as absolute</li>
<li>Additionally, paths starting with slashes like <code class="code">/c:/</code> mean the same</li>
<li>UNC paths starting with two slashes like <code class="code">//hostname</code> are supported</li>
</ul>

    However, when a <code class="code">root</code> directory is passed, these additional
    notations are not possible anymore - paths must start with <code class="code">/</code>,
    and there is neither support for drive letters nor for UNC paths.
<p>

    The <code class="code">encoding</code> arg defaults to current ANSI codepage, 
    and it is
    not supported to request a different encoding. (The difficulty is
    that the Win32 bindings of the relevant OS functions always assume
    the ANSI encoding.)
<p>

    There is no support for backslashes as path separators (such paths
    will be rejected), for better compatibility with other platforms.<br>
<br>
<h2 id="2_OSNotes">OS Notes</h2><br>
<br>
<b>Unix</b> in general: There is no notion of character encoding of
    paths. Paths are just bytes. Because of this, the default encoding
    is <code class="code">None</code>. If a different encoding is passed to <code class="code">local_fs</code>, these
    bytes are just interpreted in this encoding. There is no conversion.
<p>

    For desktop programs, though, usually the character encoding of the
    locale is taken for filenames. You can get this by passing
<p>

    <pre class="codepre"><code class="code">    let encoding = 
      Netconversion.user_encoding()
    </code></pre>
<p>

    as <code class="code">encoding</code> argument.<br>
<br>
<b>Windows</b>: If the <code class="code">root</code> argument is <b>not</b> passed to <code class="code">local_fs</code>
    it is possible to access the whole filesystem:
<p>
<ul>
<li>Paths starting with drive letters like <code class="code">c:/</code> are also considered
      as absolute</li>
<li>Additionally, paths starting with slashes like <code class="code">/c:/</code> mean the same</li>
<li>UNC paths starting with two slashes like <code class="code">//hostname</code> are supported</li>
</ul>

    However, when a <code class="code">root</code> directory is passed, these additional
    notations are not possible anymore - paths must start with <code class="code">/</code>,
    and there is neither support for drive letters nor for UNC paths.
<p>

    The <code class="code">encoding</code> arg defaults to current ANSI codepage, 
    and it is
    not supported to request a different encoding. (The difficulty is
    that the Win32 bindings of the relevant OS functions always assume
    the ANSI encoding.)
<p>

    There is no support for backslashes as path separators (such paths
    will be rejected), for better compatibility with other platforms.<br>
<br>
<h2 id="links">Other impementations of <code class="code">stream_fs</code></h2><br>
<br>
<h2 id="2_OSNotes">OS Notes</h2><br>
<br>
<b>Unix</b> in general: There is no notion of character encoding of
    paths. Paths are just bytes. Because of this, the default encoding
    is <code class="code">None</code>. If a different encoding is passed to <code class="code">local_fs</code>, these
    bytes are just interpreted in this encoding. There is no conversion.
<p>

    For desktop programs, though, usually the character encoding of the
    locale is taken for filenames. You can get this by passing
<p>

    <pre class="codepre"><code class="code">    let encoding = 
      Netconversion.user_encoding()
    </code></pre>
<p>

    as <code class="code">encoding</code> argument.<br>
<br>
<b>Windows</b>: If the <code class="code">root</code> argument is <b>not</b> passed to <code class="code">local_fs</code>
    it is possible to access the whole filesystem:
<p>
<ul>
<li>Paths starting with drive letters like <code class="code">c:/</code> are also considered
      as absolute</li>
<li>Additionally, paths starting with slashes like <code class="code">/c:/</code> mean the same</li>
<li>UNC paths starting with two slashes like <code class="code">//hostname</code> are supported</li>
</ul>

    However, when a <code class="code">root</code> directory is passed, these additional
    notations are not possible anymore - paths must start with <code class="code">/</code>,
    and there is neither support for drive letters nor for UNC paths.
<p>

    The <code class="code">encoding</code> arg defaults to current ANSI codepage, 
    and it is
    not supported to request a different encoding. (The difficulty is
    that the Win32 bindings of the relevant OS functions always assume
    the ANSI encoding.)
<p>

    There is no support for backslashes as path separators (such paths
    will be rejected), for better compatibility with other platforms.<br>
<br>
<h2 id="links">Other impementations of <code class="code">stream_fs</code></h2><br>
<br>
List:
<p>
<ul>
<li><a href="Nethttp_fs.html"><code class="code">Nethttp_fs</code></a> allows one to access HTTP-based filesystems</li>
<li><a href="Netftp_fs.html"><code class="code">Netftp_fs</code></a> allows on to access filesystems via FTP</li>
<li><a href="Shell_fs.html"><code class="code">Shell_fs</code></a> allows one to access filesystems by executing shell
      commands. This works locally and via ssh.</li>
</ul>

    There are even some implementations outside Ocamlnet:<ul>
<li><a href="http://projects.camlcity.org/projects/webdav.html"> Webdav</a>
      provides an extension of
      <a href="Nethttp_fs.html"><code class="code">Nethttp_fs</code></a> for the full WebDAV set of filesystem operations</li>
</ul>
<br>
<br>
<h2 id="2_OSNotes">OS Notes</h2><br>
<br>
<b>Unix</b> in general: There is no notion of character encoding of
    paths. Paths are just bytes. Because of this, the default encoding
    is <code class="code">None</code>. If a different encoding is passed to <code class="code">local_fs</code>, these
    bytes are just interpreted in this encoding. There is no conversion.
<p>

    For desktop programs, though, usually the character encoding of the
    locale is taken for filenames. You can get this by passing
<p>

    <pre class="codepre"><code class="code">    let encoding = 
      Netconversion.user_encoding()
    </code></pre>
<p>

    as <code class="code">encoding</code> argument.<br>
<br>
<b>Windows</b>: If the <code class="code">root</code> argument is <b>not</b> passed to <code class="code">local_fs</code>
    it is possible to access the whole filesystem:
<p>
<ul>
<li>Paths starting with drive letters like <code class="code">c:/</code> are also considered
      as absolute</li>
<li>Additionally, paths starting with slashes like <code class="code">/c:/</code> mean the same</li>
<li>UNC paths starting with two slashes like <code class="code">//hostname</code> are supported</li>
</ul>

    However, when a <code class="code">root</code> directory is passed, these additional
    notations are not possible anymore - paths must start with <code class="code">/</code>,
    and there is neither support for drive letters nor for UNC paths.
<p>

    The <code class="code">encoding</code> arg defaults to current ANSI codepage, 
    and it is
    not supported to request a different encoding. (The difficulty is
    that the Win32 bindings of the relevant OS functions always assume
    the ANSI encoding.)
<p>

    There is no support for backslashes as path separators (such paths
    will be rejected), for better compatibility with other platforms.<br>
<br>
<h2 id="links">Other impementations of <code class="code">stream_fs</code></h2><br>
<br>
List:
<p>
<ul>
<li><a href="Nethttp_fs.html"><code class="code">Nethttp_fs</code></a> allows one to access HTTP-based filesystems</li>
<li><a href="Netftp_fs.html"><code class="code">Netftp_fs</code></a> allows on to access filesystems via FTP</li>
<li><a href="Shell_fs.html"><code class="code">Shell_fs</code></a> allows one to access filesystems by executing shell
      commands. This works locally and via ssh.</li>
</ul>

    There are even some implementations outside Ocamlnet:<ul>
<li><a href="http://projects.camlcity.org/projects/webdav.html"> Webdav</a>
      provides an extension of
      <a href="Nethttp_fs.html"><code class="code">Nethttp_fs</code></a> for the full WebDAV set of filesystem operations</li>
</ul>
<br>
<br>
<h2 id="2_Algorithms">Algorithms</h2><br>

<pre><span id="VALcopy"><span class="keyword">val</span> copy</span> : <code class="type">?replace:bool -><br>       ?streaming:bool -><br>       #<a href="Netfs.stream_fs-c.html">stream_fs</a> -> string -> #<a href="Netfs.stream_fs-c.html">stream_fs</a> -> string -> unit</code></pre><div class="info ">
<code class="code">copy orig_fs orig_name dest_fs dest_name</code>: Copies the file <code class="code">orig_name</code>
      from <code class="code">orig_fs</code> to the file <code class="code">dest_name</code> in <code class="code">dest_fs</code>. By default,
      the destination file is truncated and overwritten if it already
      exists.
<p>

      If <code class="code">orig_fs</code> and <code class="code">dest_fs</code> are the same object, the <code class="code">copy</code> method
      is called to perform the operation. Otherwise, the data is read
      chunk by chunk from the file in <code class="code">orig_fs</code> and then written to
      the destination file in <code class="code">dest_fs</code>.
<p>

      Symlinks are resolved, and the linked file is copied, not the
      link as such.
<p>

      The copy does not preserve ownerships, file permissions, or
      timestamps. (The <code class="code">stream_fs</code> object does not represent these.)
      There is no protection against copying an object to itself.
<p>
<ul>
<li><code class="code">replace</code>: If set, the destination file is removed and created again
        if it already exists</li>
<li><code class="code">streaming</code>: use streaming mode for reading and writing files</li>
</ul>
<br>
</div>

<pre><span id="VALcopy_into"><span class="keyword">val</span> copy_into</span> : <code class="type">?replace:bool -><br>       ?subst:(int -> string) -><br>       ?streaming:bool -><br>       #<a href="Netfs.stream_fs-c.html">stream_fs</a> -> string -> #<a href="Netfs.stream_fs-c.html">stream_fs</a> -> string -> unit</code></pre><div class="info ">
<code class="code">copy_into orig_fs orig_name dest_fs dest_name</code>: 
      Like <code class="code">copy</code>, but this version also supports recursive copies. The
      <code class="code">dest_name</code> must be an existing directory, and the file or tree at
      <code class="code">orig_name</code> is copied into it.
<p>

      Symlinks are copied as symlinks.
<p>

      If <code class="code">replace</code> and the destination file/directory already exists,
      it is deleted before doing the copy.
<p>
<ul>
<li><code class="code">subst</code>: See <a href="Netfs.html#VALconvert_path"><code class="code">Netfs.convert_path</code></a></li>
<li><code class="code">streaming</code>: use streaming mode for reading and writing files</li>
</ul>
<br>
</div>

<pre><span id="TYPEfile_kind"><span class="keyword">type</span> <code class="type"></code>file_kind</span> = <code class="type">[ `Directory | `None | `Other | `Regular | `Symlink ]</code> </pre>


<pre><span id="VALiter"><span class="keyword">val</span> iter</span> : <code class="type">pre:(string -> <a href="Netfs.html#TYPEfile_kind">file_kind</a> -> <a href="Netfs.html#TYPEfile_kind">file_kind</a> -> unit) -><br>       ?post:(string -> unit) -> #<a href="Netfs.stream_fs-c.html">stream_fs</a> -> string -> unit</code></pre><div class="info ">
<code class="code">iter pre fs start</code>: Iterates over the file hierarchy at <code class="code">start</code>.
      The function <code class="code">pre</code> is called for every filename. The filenames
      passed to <code class="code">pre</code> are relative to <code class="code">start</code>. The <code class="code">start</code> must
      be a directory.
<p>

      For directories, the <code class="code">pre</code> function is called for the directory
      before it is called for the members of the directories.
      The function <code class="code">post</code> can additionally be passed. It is only called
      for directories, but after the members.
<p>

      <code class="code">pre</code> is called as <code class="code">pre rk lk</code> where <code class="code">rk</code> is the file kind after
      following symlinks and <code class="code">lk</code> the file kind without following symlinks
      (the link itself).
<p>

      Example: <code class="code">iter pre fs "/foo"</code> would call<ul>
<li><code class="code">pre "dir" `Directory `Directory</code> (meaning the directory "/foo/dir")</li>
<li><code class="code">pre "dir/file1" `File `File</code></li>
<li><code class="code">pre "dir/file2" `File `Symlink</code></li>
<li><code class="code">post "dir"</code></li>
</ul>

      Note: symlinks to non-existing files are reported as
      <code class="code">pre name `None `Symlink</code>.<br>
</div>

<pre><span id="VALconvert_path"><span class="keyword">val</span> convert_path</span> : <code class="type">?subst:(int -> string) -><br>       #<a href="Netfs.stream_fs-c.html">stream_fs</a> -> #<a href="Netfs.stream_fs-c.html">stream_fs</a> -> string -> string</code></pre><div class="info ">
<code class="code">convert_path oldfs newfs oldpath</code>: The encoding of <code class="code">oldpath</code>
      (which is assumed to reside in <code class="code">oldfs</code>) is converted to the encoding
      of <code class="code">newfs</code> and returned.
<p>

      It is possible that the conversion is not possible, and
      the function <code class="code">subst</code> is then called with the problematic code point as
      argument (in the encoding of <code class="code">oldfs</code>). The default <code class="code">subst</code> function
      just raises <a href="Netconversion.html#EXCEPTIONCannot_represent"><code class="code">Netconversion.Cannot_represent</code></a>.
<p>

      If one of the filesystem objects does not specify an encoding,
      the file name is not converted, but simply returned as-is. This
      may result in errors when <code class="code">newfs</code> has an encoding while <code class="code">oldfs</code>
      does not have one because the file name might use byte representations
      that are illegal in <code class="code">newfs</code>.<br>
</div>
</body></html>