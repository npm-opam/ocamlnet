<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<link rel="stylesheet" href="style.css" type="text/css">
<meta content="text/html; charset=iso-8859-1" http-equiv="Content-Type">
<link rel="Start" href="index.html">
<link rel="previous" href="Nettls_gnutls.GNUTLS.html">
<link rel="next" href="Nettls_gnutls.Symmetric_crypto.html">
<link rel="Up" href="Nettls_gnutls.html">
<link title="Index of types" rel=Appendix href="index_types.html">
<link title="Index of extensions" rel=Appendix href="index_extensions.html">
<link title="Index of exceptions" rel=Appendix href="index_exceptions.html">
<link title="Index of values" rel=Appendix href="index_values.html">
<link title="Index of class attributes" rel=Appendix href="index_attributes.html">
<link title="Index of class methods" rel=Appendix href="index_methods.html">
<link title="Index of classes" rel=Appendix href="index_classes.html">
<link title="Index of class types" rel=Appendix href="index_class_types.html">
<link title="Index of modules" rel=Appendix href="index_modules.html">
<link title="Index of module types" rel=Appendix href="index_module_types.html">
<link title="Uq_gtk" rel="Chapter" href="Uq_gtk.html">
<link title="Uq_tcl" rel="Chapter" href="Uq_tcl.html">
<link title="Equeue" rel="Chapter" href="Equeue.html">
<link title="Unixqueue" rel="Chapter" href="Unixqueue.html">
<link title="Unixqueue_pollset" rel="Chapter" href="Unixqueue_pollset.html">
<link title="Unixqueue_select" rel="Chapter" href="Unixqueue_select.html">
<link title="Uq_resolver" rel="Chapter" href="Uq_resolver.html">
<link title="Uq_engines" rel="Chapter" href="Uq_engines.html">
<link title="Uq_multiplex" rel="Chapter" href="Uq_multiplex.html">
<link title="Uq_transfer" rel="Chapter" href="Uq_transfer.html">
<link title="Uq_socks5" rel="Chapter" href="Uq_socks5.html">
<link title="Uq_io" rel="Chapter" href="Uq_io.html">
<link title="Uq_lwt" rel="Chapter" href="Uq_lwt.html">
<link title="Uq_libevent" rel="Chapter" href="Uq_libevent.html">
<link title="Uq_mt" rel="Chapter" href="Uq_mt.html">
<link title="Uq_client" rel="Chapter" href="Uq_client.html">
<link title="Uq_server" rel="Chapter" href="Uq_server.html">
<link title="Uq_datagram" rel="Chapter" href="Uq_datagram.html">
<link title="Uq_engines_compat" rel="Chapter" href="Uq_engines_compat.html">
<link title="Equeue_intro" rel="Chapter" href="Equeue_intro.html">
<link title="Equeue_howto" rel="Chapter" href="Equeue_howto.html">
<link title="Netcamlbox" rel="Chapter" href="Netcamlbox.html">
<link title="Netcgi_apache" rel="Chapter" href="Netcgi_apache.html">
<link title="Netcgi_modtpl" rel="Chapter" href="Netcgi_modtpl.html">
<link title="Netcgi_plex" rel="Chapter" href="Netcgi_plex.html">
<link title="Netcgi_common" rel="Chapter" href="Netcgi_common.html">
<link title="Netcgi" rel="Chapter" href="Netcgi.html">
<link title="Netcgi_ajp" rel="Chapter" href="Netcgi_ajp.html">
<link title="Netcgi_scgi" rel="Chapter" href="Netcgi_scgi.html">
<link title="Netcgi_cgi" rel="Chapter" href="Netcgi_cgi.html">
<link title="Netcgi_fcgi" rel="Chapter" href="Netcgi_fcgi.html">
<link title="Netcgi_dbi" rel="Chapter" href="Netcgi_dbi.html">
<link title="Netcgi1_compat" rel="Chapter" href="Netcgi1_compat.html">
<link title="Netcgi_test" rel="Chapter" href="Netcgi_test.html">
<link title="Netcgi_porting" rel="Chapter" href="Netcgi_porting.html">
<link title="Nethttp_client_conncache" rel="Chapter" href="Nethttp_client_conncache.html">
<link title="Nethttp_client" rel="Chapter" href="Nethttp_client.html">
<link title="Nettelnet_client" rel="Chapter" href="Nettelnet_client.html">
<link title="Netftp_data_endpoint" rel="Chapter" href="Netftp_data_endpoint.html">
<link title="Netftp_client" rel="Chapter" href="Netftp_client.html">
<link title="Nethttp_fs" rel="Chapter" href="Nethttp_fs.html">
<link title="Netftp_fs" rel="Chapter" href="Netftp_fs.html">
<link title="Netsmtp" rel="Chapter" href="Netsmtp.html">
<link title="Netpop" rel="Chapter" href="Netpop.html">
<link title="Netldap" rel="Chapter" href="Netldap.html">
<link title="Netclient_tut" rel="Chapter" href="Netclient_tut.html">
<link title="Netgss_bindings" rel="Chapter" href="Netgss_bindings.html">
<link title="Netgss" rel="Chapter" href="Netgss.html">
<link title="Nethttpd_types" rel="Chapter" href="Nethttpd_types.html">
<link title="Nethttpd_kernel" rel="Chapter" href="Nethttpd_kernel.html">
<link title="Nethttpd_reactor" rel="Chapter" href="Nethttpd_reactor.html">
<link title="Nethttpd_engine" rel="Chapter" href="Nethttpd_engine.html">
<link title="Nethttpd_services" rel="Chapter" href="Nethttpd_services.html">
<link title="Nethttpd_plex" rel="Chapter" href="Nethttpd_plex.html">
<link title="Nethttpd_util" rel="Chapter" href="Nethttpd_util.html">
<link title="Nethttpd_intro" rel="Chapter" href="Nethttpd_intro.html">
<link title="Netmcore" rel="Chapter" href="Netmcore.html">
<link title="Netmcore_camlbox" rel="Chapter" href="Netmcore_camlbox.html">
<link title="Netmcore_mempool" rel="Chapter" href="Netmcore_mempool.html">
<link title="Netmcore_heap" rel="Chapter" href="Netmcore_heap.html">
<link title="Netmcore_ref" rel="Chapter" href="Netmcore_ref.html">
<link title="Netmcore_array" rel="Chapter" href="Netmcore_array.html">
<link title="Netmcore_sem" rel="Chapter" href="Netmcore_sem.html">
<link title="Netmcore_mutex" rel="Chapter" href="Netmcore_mutex.html">
<link title="Netmcore_condition" rel="Chapter" href="Netmcore_condition.html">
<link title="Netmcore_queue" rel="Chapter" href="Netmcore_queue.html">
<link title="Netmcore_buffer" rel="Chapter" href="Netmcore_buffer.html">
<link title="Netmcore_matrix" rel="Chapter" href="Netmcore_matrix.html">
<link title="Netmcore_hashtbl" rel="Chapter" href="Netmcore_hashtbl.html">
<link title="Netmcore_process" rel="Chapter" href="Netmcore_process.html">
<link title="Netmcore_tut" rel="Chapter" href="Netmcore_tut.html">
<link title="Netmcore_basics" rel="Chapter" href="Netmcore_basics.html">
<link title="Netplex_types" rel="Chapter" href="Netplex_types.html">
<link title="Netplex_mp" rel="Chapter" href="Netplex_mp.html">
<link title="Netplex_mt" rel="Chapter" href="Netplex_mt.html">
<link title="Netplex_log" rel="Chapter" href="Netplex_log.html">
<link title="Netplex_controller" rel="Chapter" href="Netplex_controller.html">
<link title="Netplex_container" rel="Chapter" href="Netplex_container.html">
<link title="Netplex_sockserv" rel="Chapter" href="Netplex_sockserv.html">
<link title="Netplex_workload" rel="Chapter" href="Netplex_workload.html">
<link title="Netplex_main" rel="Chapter" href="Netplex_main.html">
<link title="Netplex_config" rel="Chapter" href="Netplex_config.html">
<link title="Netplex_kit" rel="Chapter" href="Netplex_kit.html">
<link title="Rpc_netplex" rel="Chapter" href="Rpc_netplex.html">
<link title="Netplex_cenv" rel="Chapter" href="Netplex_cenv.html">
<link title="Netplex_semaphore" rel="Chapter" href="Netplex_semaphore.html">
<link title="Netplex_sharedvar" rel="Chapter" href="Netplex_sharedvar.html">
<link title="Netplex_mutex" rel="Chapter" href="Netplex_mutex.html">
<link title="Netplex_encap" rel="Chapter" href="Netplex_encap.html">
<link title="Netplex_mbox" rel="Chapter" href="Netplex_mbox.html">
<link title="Netplex_internal" rel="Chapter" href="Netplex_internal.html">
<link title="Netplex_intro" rel="Chapter" href="Netplex_intro.html">
<link title="Netplex_advanced" rel="Chapter" href="Netplex_advanced.html">
<link title="Netplex_admin" rel="Chapter" href="Netplex_admin.html">
<link title="Netshm" rel="Chapter" href="Netshm.html">
<link title="Netshm_data" rel="Chapter" href="Netshm_data.html">
<link title="Netshm_hashtbl" rel="Chapter" href="Netshm_hashtbl.html">
<link title="Netshm_array" rel="Chapter" href="Netshm_array.html">
<link title="Netshm_intro" rel="Chapter" href="Netshm_intro.html">
<link title="Netstring_pcre" rel="Chapter" href="Netstring_pcre.html">
<link title="Netconversion" rel="Chapter" href="Netconversion.html">
<link title="Netchannels" rel="Chapter" href="Netchannels.html">
<link title="Netstream" rel="Chapter" href="Netstream.html">
<link title="Netmime_string" rel="Chapter" href="Netmime_string.html">
<link title="Netmime" rel="Chapter" href="Netmime.html">
<link title="Netsendmail" rel="Chapter" href="Netsendmail.html">
<link title="Neturl" rel="Chapter" href="Neturl.html">
<link title="Netaddress" rel="Chapter" href="Netaddress.html">
<link title="Netbuffer" rel="Chapter" href="Netbuffer.html">
<link title="Netmime_header" rel="Chapter" href="Netmime_header.html">
<link title="Netmime_channels" rel="Chapter" href="Netmime_channels.html">
<link title="Neturl_ldap" rel="Chapter" href="Neturl_ldap.html">
<link title="Netdate" rel="Chapter" href="Netdate.html">
<link title="Netencoding" rel="Chapter" href="Netencoding.html">
<link title="Netulex" rel="Chapter" href="Netulex.html">
<link title="Netaccel" rel="Chapter" href="Netaccel.html">
<link title="Netaccel_link" rel="Chapter" href="Netaccel_link.html">
<link title="Nethtml" rel="Chapter" href="Nethtml.html">
<link title="Netstring_str" rel="Chapter" href="Netstring_str.html">
<link title="Netmappings" rel="Chapter" href="Netmappings.html">
<link title="Netaux" rel="Chapter" href="Netaux.html">
<link title="Nethttp" rel="Chapter" href="Nethttp.html">
<link title="Netpagebuffer" rel="Chapter" href="Netpagebuffer.html">
<link title="Netfs" rel="Chapter" href="Netfs.html">
<link title="Netglob" rel="Chapter" href="Netglob.html">
<link title="Netauth" rel="Chapter" href="Netauth.html">
<link title="Netsockaddr" rel="Chapter" href="Netsockaddr.html">
<link title="Netnumber" rel="Chapter" href="Netnumber.html">
<link title="Netxdr_mstring" rel="Chapter" href="Netxdr_mstring.html">
<link title="Netxdr" rel="Chapter" href="Netxdr.html">
<link title="Netcompression" rel="Chapter" href="Netcompression.html">
<link title="Netunichar" rel="Chapter" href="Netunichar.html">
<link title="Netasn1" rel="Chapter" href="Netasn1.html">
<link title="Netasn1_encode" rel="Chapter" href="Netasn1_encode.html">
<link title="Netoid" rel="Chapter" href="Netoid.html">
<link title="Netstring_tstring" rel="Chapter" href="Netstring_tstring.html">
<link title="Netdn" rel="Chapter" href="Netdn.html">
<link title="Netx509" rel="Chapter" href="Netx509.html">
<link title="Netascii_armor" rel="Chapter" href="Netascii_armor.html">
<link title="Nettls_support" rel="Chapter" href="Nettls_support.html">
<link title="Netmech_scram" rel="Chapter" href="Netmech_scram.html">
<link title="Netmech_scram_gssapi" rel="Chapter" href="Netmech_scram_gssapi.html">
<link title="Netmech_scram_sasl" rel="Chapter" href="Netmech_scram_sasl.html">
<link title="Netmech_scram_http" rel="Chapter" href="Netmech_scram_http.html">
<link title="Netgssapi_support" rel="Chapter" href="Netgssapi_support.html">
<link title="Netgssapi_auth" rel="Chapter" href="Netgssapi_auth.html">
<link title="Netchannels_crypto" rel="Chapter" href="Netchannels_crypto.html">
<link title="Netx509_pubkey" rel="Chapter" href="Netx509_pubkey.html">
<link title="Netx509_pubkey_crypto" rel="Chapter" href="Netx509_pubkey_crypto.html">
<link title="Netsaslprep" rel="Chapter" href="Netsaslprep.html">
<link title="Netmech_plain_sasl" rel="Chapter" href="Netmech_plain_sasl.html">
<link title="Netmech_crammd5_sasl" rel="Chapter" href="Netmech_crammd5_sasl.html">
<link title="Netmech_digest_sasl" rel="Chapter" href="Netmech_digest_sasl.html">
<link title="Netmech_digest_http" rel="Chapter" href="Netmech_digest_http.html">
<link title="Netmech_krb5_sasl" rel="Chapter" href="Netmech_krb5_sasl.html">
<link title="Netmech_gs2_sasl" rel="Chapter" href="Netmech_gs2_sasl.html">
<link title="Netmech_spnego_http" rel="Chapter" href="Netmech_spnego_http.html">
<link title="Netchannels_tut" rel="Chapter" href="Netchannels_tut.html">
<link title="Netmime_tut" rel="Chapter" href="Netmime_tut.html">
<link title="Netsendmail_tut" rel="Chapter" href="Netsendmail_tut.html">
<link title="Netulex_tut" rel="Chapter" href="Netulex_tut.html">
<link title="Neturl_tut" rel="Chapter" href="Neturl_tut.html">
<link title="Netsys" rel="Chapter" href="Netsys.html">
<link title="Netsys_posix" rel="Chapter" href="Netsys_posix.html">
<link title="Netsys_pollset" rel="Chapter" href="Netsys_pollset.html">
<link title="Netlog" rel="Chapter" href="Netlog.html">
<link title="Netexn" rel="Chapter" href="Netexn.html">
<link title="Netsys_win32" rel="Chapter" href="Netsys_win32.html">
<link title="Netsys_pollset_posix" rel="Chapter" href="Netsys_pollset_posix.html">
<link title="Netsys_pollset_win32" rel="Chapter" href="Netsys_pollset_win32.html">
<link title="Netsys_pollset_generic" rel="Chapter" href="Netsys_pollset_generic.html">
<link title="Netsys_signal" rel="Chapter" href="Netsys_signal.html">
<link title="Netsys_oothr" rel="Chapter" href="Netsys_oothr.html">
<link title="Netsys_xdr" rel="Chapter" href="Netsys_xdr.html">
<link title="Netsys_rng" rel="Chapter" href="Netsys_rng.html">
<link title="Netsys_crypto_types" rel="Chapter" href="Netsys_crypto_types.html">
<link title="Netsys_types" rel="Chapter" href="Netsys_types.html">
<link title="Netsys_mem" rel="Chapter" href="Netsys_mem.html">
<link title="Netsys_tmp" rel="Chapter" href="Netsys_tmp.html">
<link title="Netsys_sem" rel="Chapter" href="Netsys_sem.html">
<link title="Netsys_pmanage" rel="Chapter" href="Netsys_pmanage.html">
<link title="Netsys_crypto" rel="Chapter" href="Netsys_crypto.html">
<link title="Netsys_tls" rel="Chapter" href="Netsys_tls.html">
<link title="Netsys_ciphers" rel="Chapter" href="Netsys_ciphers.html">
<link title="Netsys_digests" rel="Chapter" href="Netsys_digests.html">
<link title="Netsys_crypto_modes" rel="Chapter" href="Netsys_crypto_modes.html">
<link title="Netsys_gssapi" rel="Chapter" href="Netsys_gssapi.html">
<link title="Netsys_sasl_types" rel="Chapter" href="Netsys_sasl_types.html">
<link title="Netsys_sasl" rel="Chapter" href="Netsys_sasl.html">
<link title="Netsys_polypipe" rel="Chapter" href="Netsys_polypipe.html">
<link title="Netsys_polysocket" rel="Chapter" href="Netsys_polysocket.html">
<link title="Netsys_global" rel="Chapter" href="Netsys_global.html">
<link title="Nettls_gnutls_bindings" rel="Chapter" href="Nettls_gnutls_bindings.html">
<link title="Nettls_nettle_bindings" rel="Chapter" href="Nettls_nettle_bindings.html">
<link title="Nettls_gnutls" rel="Chapter" href="Nettls_gnutls.html">
<link title="Netunidata" rel="Chapter" href="Netunidata.html">
<link title="Netgzip" rel="Chapter" href="Netgzip.html">
<link title="Rpc_auth_local" rel="Chapter" href="Rpc_auth_local.html">
<link title="Rpc_xti_client" rel="Chapter" href="Rpc_xti_client.html">
<link title="Rpc" rel="Chapter" href="Rpc.html">
<link title="Rpc_program" rel="Chapter" href="Rpc_program.html">
<link title="Rpc_util" rel="Chapter" href="Rpc_util.html">
<link title="Rpc_portmapper_aux" rel="Chapter" href="Rpc_portmapper_aux.html">
<link title="Rpc_packer" rel="Chapter" href="Rpc_packer.html">
<link title="Rpc_transport" rel="Chapter" href="Rpc_transport.html">
<link title="Rpc_client" rel="Chapter" href="Rpc_client.html">
<link title="Rpc_simple_client" rel="Chapter" href="Rpc_simple_client.html">
<link title="Rpc_portmapper_clnt" rel="Chapter" href="Rpc_portmapper_clnt.html">
<link title="Rpc_portmapper" rel="Chapter" href="Rpc_portmapper.html">
<link title="Rpc_server" rel="Chapter" href="Rpc_server.html">
<link title="Rpc_auth_sys" rel="Chapter" href="Rpc_auth_sys.html">
<link title="Rpc_auth_gssapi" rel="Chapter" href="Rpc_auth_gssapi.html">
<link title="Rpc_proxy" rel="Chapter" href="Rpc_proxy.html">
<link title="Rpc_intro" rel="Chapter" href="Rpc_intro.html">
<link title="Rpc_mapping_ref" rel="Chapter" href="Rpc_mapping_ref.html">
<link title="Rpc_intro_gss" rel="Chapter" href="Rpc_intro_gss.html">
<link title="Shell_sys" rel="Chapter" href="Shell_sys.html">
<link title="Shell" rel="Chapter" href="Shell.html">
<link title="Shell_uq" rel="Chapter" href="Shell_uq.html">
<link title="Shell_fs" rel="Chapter" href="Shell_fs.html">
<link title="Shell_intro" rel="Chapter" href="Shell_intro.html">
<link title="Intro" rel="Chapter" href="Intro.html">
<link title="Platform" rel="Chapter" href="Platform.html">
<link title="Foreword" rel="Chapter" href="Foreword.html">
<link title="Ipv6" rel="Chapter" href="Ipv6.html">
<link title="Regexp" rel="Chapter" href="Regexp.html">
<link title="Tls" rel="Chapter" href="Tls.html">
<link title="Crypto" rel="Chapter" href="Crypto.html">
<link title="Authentication" rel="Chapter" href="Authentication.html">
<link title="Credentials" rel="Chapter" href="Credentials.html">
<link title="Gssapi" rel="Chapter" href="Gssapi.html">
<link title="Ocamlnet4" rel="Chapter" href="Ocamlnet4.html">
<link title="Get" rel="Chapter" href="Get.html"><title>Ocamlnet 4 Reference Manual : Nettls_gnutls.TLS</title>
</head>
<body>
<div class="navbar"><a class="pre" href="Nettls_gnutls.GNUTLS.html" title="Nettls_gnutls.GNUTLS">Previous</a>
&nbsp;<a class="up" href="Nettls_gnutls.html" title="Nettls_gnutls">Up</a>
&nbsp;<a class="post" href="Nettls_gnutls.Symmetric_crypto.html" title="Nettls_gnutls.Symmetric_crypto">Next</a>
</div>
<h1>Module <a href="type_Nettls_gnutls.TLS.html">Nettls_gnutls.TLS</a></h1>

<pre><span class="keyword">module</span> TLS: <code class="type"><a href="Netsys_crypto_types.TLS_PROVIDER.html">Netsys_crypto_types.TLS_PROVIDER</a></code><code class="type"> </code></pre><div class="info module top">
Same as <code class="code">GNUTLS</code>, but without the extra <code class="code">gnutls_*</code> functions<br>
</div>
<hr width="100%">
<br>
Provides TLS functionality.
<p>

        Users should not call functions of the provider directly, but use
        <a href="Netsys_tls.html"><code class="code">Netsys_tls</code></a>, or another higher-level layer.<br>

<pre><span id="TYPEconfig"><span class="keyword">type</span> <code class="type"></code>config</span> </pre>


<pre><span id="TYPEcredentials"><span class="keyword">type</span> <code class="type"></code>credentials</span> </pre>


<pre><span id="TYPEendpoint"><span class="keyword">type</span> <code class="type"></code>endpoint</span> </pre>


<pre><span class="keyword">module</span> <a href="Netsys_crypto_types.TLS_PROVIDER.Exc.html">Exc</a>: <code class="type"><a href="Netsys_crypto_types.TLS_EXCEPTIONS.html">Netsys_crypto_types.TLS_EXCEPTIONS</a></code><code class="type"> </code></pre><div class="info">
Access to exceptions
</div>

<pre><span id="VALerror_message"><span class="keyword">val</span> error_message</span> : <code class="type">string -> string</code></pre><div class="info ">
Returns the message for humans (display, log files etc.) when
          called with an error or warning symbol.<br>
</div>

<pre><span id="TYPEdh_params"><span class="keyword">type</span> <code class="type"></code>dh_params</span> = <code class="type">[ `Generate of int | `PKCS3_DER of string | `PKCS3_PEM_file of string ]</code> </pre>
<div class="info ">
Diffie-Hellman parameters:
<p>
<ul>
<li><code class="code">`PKCS3_PEM_file name</code>: points to a PEM-encoded PKCS3-file
             ("BEGIN DH PARAMETERS")</li>
<li><code class="code">`PKCS3_DER data</code>: the parameters are in a DER-encoded PKCS3
             structure</li>
<li><code class="code">`Generate bits</code>: the parameters are generated with the
             passed number of bits</li>
</ul>
<br>
</div>


<pre><span id="VALcreate_config"><span class="keyword">val</span> create_config</span> : <code class="type">?algorithms:string -><br>       ?dh_params:<a href="Netsys_crypto_types.TLS_PROVIDER.html#TYPEdh_params">dh_params</a> -><br>       ?verify:(<a href="Netsys_crypto_types.TLS_PROVIDER.html#TYPEendpoint">endpoint</a> -> bool -> bool -> bool) -><br>       peer_auth:[ `None | `Optional | `Required ] -><br>       credentials:<a href="Netsys_crypto_types.TLS_PROVIDER.html#TYPEcredentials">credentials</a> -><br>       unit -> <a href="Netsys_crypto_types.TLS_PROVIDER.html#TYPEconfig">config</a></code></pre><div class="info ">
The configuration includes:
<p>
<ul>
<li><code class="code">algorithms</code>: a string specifying which cryptographic algorithms,
            protocols and protocol options
            are enabled, and in which priority they are used in the negotiation.
            (GnuTLS calls this "priority string".) The syntax is
            implementation-defined.</li>
<li><code class="code">dh_params</code>: parameters for Diffie-Hellman key exchange (used for
            DH-based authentication, but only on the server side)</li>
<li><code class="code">peer_auth</code>: controls whether the peer is requested to authenticate.
            This can be set to <code class="code">`None</code> meaning not to request authentication
            and to ignore credentials, or to <code class="code">`Optional</code> meaning not to request
            authentication but to check credentials if they are sent 
            nevertheless, or to <code class="code">`Required</code> meaning to request and check
            credentials. For "standard clients" you should set this to
            <code class="code">`Required</code>, and for "standard servers" to <code class="code">`None</code> or
            <code class="code">`Required</code>.</li>
<li><code class="code">credentials</code> describes our own credentials, and the accepted
            credentials of the peer.</li>
<li><code class="code">verify</code> is a function called to verify the peer certificate
            in addition to the actions of <code class="code">peer_auth</code>. The function must
            return <code class="code">true</code> in order to be successful. The arguments of the
            function are the TLS endpoint, and two bools indicating the
            success of previous checks. The first bool says whether the
            certificate is trusted (based on <code class="code">peer_auth</code>, <code class="code">trust</code> and
            <code class="code">system_trust</code>), and the second bool says whether the host name
            of the peer matches the name in the certificate. If not
            passed, <code class="code">verify</code> defaults to <code class="code">(fun _ cert_ok name_ok -&gt;
            cert_ok &amp;&amp; name_ok)</code>, i.e. both bools must be true.</li>
</ul>

          A configuration is read-only once created, and can be used for
          several endpoints. In particular, it does not cache TLS sessions.<br>
</div>

<pre><span id="TYPEcrt_list"><span class="keyword">type</span> <code class="type"></code>crt_list</span> = <code class="type">[ `DER of string list | `PEM_file of string ]</code> </pre>
<div class="info ">
Certificates are given either as:
<p>
<ul>
<li><code class="code">`PEM_file name</code>: The certs are stored in this file, and are
            PEM-encoded.</li>
<li><code class="code">`DER l</code>: The certs are given directly in their DER-encoded form</li>
</ul>

          See also <a href="Credentials.html#tls"><i>Credentials for TLS</i></a>.<br>
</div>


<pre><span id="TYPEcrl_list"><span class="keyword">type</span> <code class="type"></code>crl_list</span> = <code class="type">[ `DER of string list | `PEM_file of string ]</code> </pre>
<div class="info ">
Certificate revocation lists are given either as:
<p>
<ul>
<li><code class="code">`PEM_file name</code>: The CRLs are stored in this file, and are
            PEM-encoded.</li>
<li><code class="code">`DER l</code>: The CRLs are given directly in their DER-encoded form</li>
</ul>

          See also <a href="Credentials.html#tls"><i>Credentials for TLS</i></a>.<br>
</div>


<pre><span id="TYPEprivate_key"><span class="keyword">type</span> <code class="type"></code>private_key</span> = <code class="type">[ `DSA of string<br>       | `EC of string<br>       | `PEM_file of string<br>       | `PKCS8 of string<br>       | `PKCS8_encrypted of string<br>       | `RSA of string ]</code> </pre>
<div class="info ">
Private keys are given either as:
<p>
<ul>
<li><code class="code">`PEM_file name</code>: The key is stored PEM-encoded in this file.
            The PEM header indicates the format.</li>
<li><code class="code">`RSA data</code>: The key is a PKCS1 RSA key</li>
<li><code class="code">`DSA data</code>: The key is a DSA key</li>
<li><code class="code">`EC data</code>: The key is for an elliptic curve</li>
<li><code class="code">`PKCS8 data</code>: The key is in a PKCS8 data structure</li>
<li><code class="code">`PKCS8_encrypted data</code>: The key is in a PKCS8 data structure,
            and is additionally encrypted.</li>
</ul>

          See also <a href="Credentials.html#tls"><i>Credentials for TLS</i></a>.<br>
</div>


<pre><span id="VALcreate_x509_credentials"><span class="keyword">val</span> create_x509_credentials</span> : <code class="type">?system_trust:bool -><br>       ?trust:<a href="Netsys_crypto_types.TLS_PROVIDER.html#TYPEcrt_list">crt_list</a> list -><br>       ?revoke:<a href="Netsys_crypto_types.TLS_PROVIDER.html#TYPEcrl_list">crl_list</a> list -><br>       ?keys:(<a href="Netsys_crypto_types.TLS_PROVIDER.html#TYPEcrt_list">crt_list</a> *<br>              <a href="Netsys_crypto_types.TLS_PROVIDER.html#TYPEprivate_key">private_key</a> * string option)<br>             list -><br>       unit -> <a href="Netsys_crypto_types.TLS_PROVIDER.html#TYPEcredentials">credentials</a></code></pre><div class="info ">
Create X.509 credentials from individual objects:<ul>
<li><code class="code">system_trust</code>: if set, the system certificates are trusted</li>
<li><code class="code">trust</code> specifies the CAs of peers to trust (default: empty)</li>
<li><code class="code">revoke</code> specifies CRLs for revocation of peer certificates
             (default: empty)</li>
<li><code class="code">keys</code> are our own certificates, as triples
             <code class="code">(cert_path, private_key, password)</code> (default: empty)</li>
</ul>

          A client should set <code class="code">trust</code> to the list of CAs it can accept on
          the server side. It is not required to specify a key.
<p>

          A server must specify a key (but can also specify several keys).
          If a server requests authentication from the client, it must also
          set <code class="code">trust</code>.
<p>

          The keys must include the certificate path <code class="code">cert_path</code>, starting
          with the endpoint certificate, and followed by all middle
          certificates, but omitting the certificate of the CA.
          The <code class="code">private_key</code>
          is the key of the endpoint. If it is password-encrypted, the
          password must be given.<br>
</div>

<pre><span id="VALcreate_endpoint"><span class="keyword">val</span> create_endpoint</span> : <code class="type">role:[ `Client | `Server ] -><br>       recv:(<a href="Netsys_types.html#TYPEmemory">Netsys_types.memory</a> -> int) -><br>       send:(<a href="Netsys_types.html#TYPEmemory">Netsys_types.memory</a> -> int -> int) -><br>       peer_name:string option -><br>       <a href="Netsys_crypto_types.TLS_PROVIDER.html#TYPEconfig">config</a> -><br>       <a href="Netsys_crypto_types.TLS_PROVIDER.html#TYPEendpoint">endpoint</a></code></pre><div class="info ">
Creates a new endpoint for this configuration.
<p>

          <code class="code">peer_name</code> is the expected common name or DNS name of the
          peer.  <code class="code">peer_name</code> has an option type as it is not always
          required to pass it. However, keep in mind that clients
          normally authenticate servers (<code class="code">peer_auth=`Required</code>). In
          order to do so, they need to check whether the name in the
          server certificate equals the DNS name of the service they
          are connected to. This check is done by comparing <code class="code">peer_name</code>
          with the name in the certificate.
<p>

          <code class="code">peer_name</code> is also used for the SNI extension.
<p>

          Servers normally need not to set <code class="code">peer_name</code>. You can also omit it
          when there is no name-driven authentication at all.
<p>

          The endpoint will use the functions <code class="code">recv</code> and <code class="code">send</code> for I/O, which
          must be user-supplied. <code class="code">recv buf</code> is expected to read data into the
          buffer, and to return the number of bytes, or 0 for EOF. 
          <code class="code">send buf n</code> is expected to send the <code class="code">n</code> first bytes in <code class="code">buf</code>.
<p>

          Both functions may raise <code class="code">Unix_error</code>. The codes <code class="code">Unix.EAGAIN</code> and
          <code class="code">Unix.EINTR</code> are specially interpreted.<br>
</div>

<pre><span id="VALstash_endpoint"><span class="keyword">val</span> stash_endpoint</span> : <code class="type"><a href="Netsys_crypto_types.TLS_PROVIDER.html#TYPEendpoint">endpoint</a> -> exn</code></pre><div class="info ">
The endpoint in "stashed" form, encapsulated as an exception.
          This form is intended for keeping the session alive in RAM, but
          without keeping references to the <code class="code">recv</code> and <code class="code">send</code> functions.
<p>

          The endpoint passed in to <code class="code">stash_endpoint</code> must no longer be used!<br>
</div>

<pre><span id="VALrestore_endpoint"><span class="keyword">val</span> restore_endpoint</span> : <code class="type">recv:(<a href="Netsys_types.html#TYPEmemory">Netsys_types.memory</a> -> int) -><br>       send:(<a href="Netsys_types.html#TYPEmemory">Netsys_types.memory</a> -> int -> int) -><br>       exn -> <a href="Netsys_crypto_types.TLS_PROVIDER.html#TYPEendpoint">endpoint</a></code></pre><div class="info ">
Reconnect the stashed endpoint with <code class="code">recv</code> and <code class="code">send</code> functions<br>
</div>

<pre><span id="VALresume_client"><span class="keyword">val</span> resume_client</span> : <code class="type">recv:(<a href="Netsys_types.html#TYPEmemory">Netsys_types.memory</a> -> int) -><br>       send:(<a href="Netsys_types.html#TYPEmemory">Netsys_types.memory</a> -> int -> int) -><br>       peer_name:string option -><br>       <a href="Netsys_crypto_types.TLS_PROVIDER.html#TYPEconfig">config</a> -><br>       string -> <a href="Netsys_crypto_types.TLS_PROVIDER.html#TYPEendpoint">endpoint</a></code></pre><div class="info ">
Creates a new endpoint that will resume an old session. This implies
          the client role.
<p>

          The session data is passed as string, which must have been retrieved
          with <code class="code">get_session_data</code>.<br>
</div>

<pre><span id="TYPEstate"><span class="keyword">type</span> <code class="type"></code>state</span> = <code class="type">[ `Accepting<br>       | `Data_r<br>       | `Data_rs<br>       | `Data_rw<br>       | `Data_w<br>       | `End<br>       | `Handshake<br>       | `Refusing<br>       | `Start<br>       | `Switching ]</code> </pre>
<div class="info ">
The state of a session:
<p>
<ul>
<li><code class="code">`Start</code>: Before the session is started</li>
<li><code class="code">`Handshake</code>: The handshake is being done (and <code class="code">hello</code> needs to
            be called again)</li>
<li><code class="code">`Data_rw</code>: The connection exists, and is read/write</li>
<li><code class="code">`Data_r</code>: The connection exists, and is read-only</li>
<li><code class="code">`Data_w</code>: The connection exists, and is write-only</li>
<li><code class="code">`Data_rs</code>: The connection exists, and data can be read.
            There was a switch request (initiated by us), and a response
            is awaited. No data can be sent in the moment.</li>
<li><code class="code">`Switching</code>: A rehandshake is being negotiated (and <code class="code">switch</code>
            needs to be called again)</li>
<li><code class="code">`Accepting</code>: A rehandshake is being accepted (and <code class="code">accept_switch</code>
            needs to be called again)</li>
<li><code class="code">`Refusing</code>: A rehandshake is being refused (and <code class="code">refuse_switch</code>
            needs to be called again)</li>
<li><code class="code">`End</code>: After finishing the session</li>
</ul>
<br>
</div>


<pre><span id="VALget_state"><span class="keyword">val</span> get_state</span> : <code class="type"><a href="Netsys_crypto_types.TLS_PROVIDER.html#TYPEendpoint">endpoint</a> -><br>       <a href="Netsys_crypto_types.TLS_PROVIDER.html#TYPEstate">state</a></code></pre><div class="info ">
Return the recorded state<br>
</div>

<pre><span id="TYPEraw_credentials"><span class="keyword">type</span> <code class="type"></code>raw_credentials</span> = <code class="type">[ `Anonymous | `X509 of string ]</code> </pre>
<div class="info ">
The encoded credentials:<ul>
<li><code class="code">`X509 s</code>: The X509 certificate in DER encoding</li>
<li><code class="code">`Anonymous</code>: no certificate or other key is available</li>
</ul>
<br>
</div>


<pre><span id="VALat_transport_eof"><span class="keyword">val</span> at_transport_eof</span> : <code class="type"><a href="Netsys_crypto_types.TLS_PROVIDER.html#TYPEendpoint">endpoint</a> -> bool</code></pre><div class="info ">
Whether the underlying transport channel has seen the end of
        input. Use this after <code class="code">recv</code> or <code class="code">mem_recv</code> returned 0 to
        check whether only the TLS enf-of-input message has been read,
       or the underlying channel (usually the file descriptor) has
        indicated EOF.<br>
</div>

<pre><span id="VALhello"><span class="keyword">val</span> hello</span> : <code class="type"><a href="Netsys_crypto_types.TLS_PROVIDER.html#TYPEendpoint">endpoint</a> -> unit</code></pre><div class="info ">
Performs the initial handshake (exchanges credentials and establishes
          a session).
<p>

          <code class="code">hello</code> doesn't verify the peer. Use <code class="code">verify</code> for that.
<p>

          May raise <code class="code">EAGAIN_RD</code>, <code class="code">EAGAIN_WR</code>,
          <code class="code">Unix_error(EINTR,_,_)</code>, <code class="code">Error</code> or <code class="code">Warning</code>.<br>
</div>

<pre><span id="VALbye"><span class="keyword">val</span> bye</span> : <code class="type"><a href="Netsys_crypto_types.TLS_PROVIDER.html#TYPEendpoint">endpoint</a> -> Unix.shutdown_command -> unit</code></pre><div class="info ">
Performs the final handshake (exchanges close requests).
<p>

          If <code class="code">SHUTDOWN_SEND</code> is set, the close request is sent to the peer, and
          the TLS tunnel is considered as closed for writing. The application
          can receive further data until <code class="code">recv</code> returns zero bytes meaning
          that the peer responded with another close request.
<p>

          If <code class="code">SHUTDOWN_ALL</code> is passed, it is additionally waited until the peer
          responds with a close request.
<p>

          A simple <code class="code">SHUTDOWN_RECEIVE</code> is unimplemented and ignored.
<p>

          In no case the underlying transport is closed or shut down!
<p>

          May raise <code class="code">EAGAIN_RD</code>, <code class="code">EAGAIN_WR</code>,
          <code class="code">Unix_error(EINTR,_,_)</code>, <code class="code">Error</code> or <code class="code">Warning</code>.<br>
</div>

<pre><span id="VALverify"><span class="keyword">val</span> verify</span> : <code class="type"><a href="Netsys_crypto_types.TLS_PROVIDER.html#TYPEendpoint">endpoint</a> -> unit</code></pre><div class="info ">
<code class="code">verify ep peer_name</code>: Checks that:<ul>
<li>there is a trust chain for the peer's certificate</li>
<li>that <code class="code">peer_name</code> is the common name of the certificate subject,
             or an alternate name</li>
</ul>

          <b>These checks are not performed if <code class="code">peer_auth=`None</code> is set in the
          configuration!</b>
<p>

          Additionally, the <code class="code">verify</code> function in the endpoint configuration
          is called back, and a failure is indicated if this function returns
          <code class="code">false</code>. This callback is useful to get the certificate of the peer
          and to perform further checks.
<p>

          The <code class="code">verify</code> function will raise <code class="code">Failure</code> on failed checks
          (and <code class="code">Error</code>
          for internal processing errors).<br>
</div>

<pre><span id="VALget_config"><span class="keyword">val</span> get_config</span> : <code class="type"><a href="Netsys_crypto_types.TLS_PROVIDER.html#TYPEendpoint">endpoint</a> -><br>       <a href="Netsys_crypto_types.TLS_PROVIDER.html#TYPEconfig">config</a></code></pre><div class="info ">
Get the current config (possibly modified because of a rehandshake)<br>
</div>

<pre><span id="VALget_endpoint_creds"><span class="keyword">val</span> get_endpoint_creds</span> : <code class="type"><a href="Netsys_crypto_types.TLS_PROVIDER.html#TYPEendpoint">endpoint</a> -><br>       <a href="Netsys_crypto_types.TLS_PROVIDER.html#TYPEraw_credentials">raw_credentials</a></code></pre><div class="info ">
Get the credentials that was actually used in the handshake, in raw
          format.<br>
</div>

<pre><span id="VALget_peer_creds"><span class="keyword">val</span> get_peer_creds</span> : <code class="type"><a href="Netsys_crypto_types.TLS_PROVIDER.html#TYPEendpoint">endpoint</a> -><br>       <a href="Netsys_crypto_types.TLS_PROVIDER.html#TYPEraw_credentials">raw_credentials</a></code></pre><div class="info ">
Get the credentials of the peer, in raw format. Raises <code class="code">Not_found</code>
          if not applicable/no credentials present.<br>
</div>

<pre><span id="VALget_peer_creds_list"><span class="keyword">val</span> get_peer_creds_list</span> : <code class="type"><a href="Netsys_crypto_types.TLS_PROVIDER.html#TYPEendpoint">endpoint</a> -><br>       <a href="Netsys_crypto_types.TLS_PROVIDER.html#TYPEraw_credentials">raw_credentials</a> list</code></pre><div class="info ">
Get the chain that was actually used in the handshake.<br>
</div>

<pre><span id="VALswitch"><span class="keyword">val</span> switch</span> : <code class="type"><a href="Netsys_crypto_types.TLS_PROVIDER.html#TYPEendpoint">endpoint</a> -><br>       <a href="Netsys_crypto_types.TLS_PROVIDER.html#TYPEconfig">config</a> -> unit</code></pre><div class="info ">
The server can use this to request a rehandshake and to use the
          new configuration for cert verification. This function sends the
          request, and expects a soon response from the client. The
          state enters <code class="code">`Data_rs</code> meaning that we can still read data,
          and at some point <code class="code">recv</code> will raise <code class="code">TLS_switch_response</code>.
<p>

          On the client side, the request will by returned as exception
          <code class="code">TLS_switch_request</code> by <code class="code">recv</code>. The client should respond with
          <code class="code">accept_switch</code> if it accepts the handshake, or <code class="code">refuse_switch</code> if
          not.
<p>

          May raise <code class="code">EAGAIN_RD</code>, <code class="code">EAGAIN_WR</code>,
          <code class="code">Unix_error(EINTR,_,_)</code>, <code class="code">Error</code> or <code class="code">Warning</code>.<br>
</div>

<pre><span id="VALaccept_switch"><span class="keyword">val</span> accept_switch</span> : <code class="type"><a href="Netsys_crypto_types.TLS_PROVIDER.html#TYPEendpoint">endpoint</a> -><br>       <a href="Netsys_crypto_types.TLS_PROVIDER.html#TYPEconfig">config</a> -> unit</code></pre><div class="info ">
On the client: Enter another handshake round with new configuration
          data.
<p>

          May raise <code class="code">EAGAIN_RD</code>, <code class="code">EAGAIN_WR</code>,
          <code class="code">Unix_error(EINTR,_,_)</code>, <code class="code">Error</code> or <code class="code">Warning</code>.<br>
</div>

<pre><span id="VALrefuse_switch"><span class="keyword">val</span> refuse_switch</span> : <code class="type"><a href="Netsys_crypto_types.TLS_PROVIDER.html#TYPEendpoint">endpoint</a> -> unit</code></pre><div class="info ">
On the client: Refuse a handshake
<p>

          May raise <code class="code">EAGAIN_RD</code>, <code class="code">EAGAIN_WR</code>,
          <code class="code">Unix_error(EINTR,_,_)</code>, <code class="code">Error</code> or <code class="code">Warning</code>.<br>
</div>

<pre><span id="VALsend"><span class="keyword">val</span> send</span> : <code class="type"><a href="Netsys_crypto_types.TLS_PROVIDER.html#TYPEendpoint">endpoint</a> -><br>       <a href="Netsys_types.html#TYPEmemory">Netsys_types.memory</a> -> int -> int</code></pre><div class="info ">
<code class="code">send ep buffer n</code>: Sends the first <code class="code">n</code> bytes in the buffer over
          the endpoint, and returns the actual number of processed bytes.
<p>

          May raise <code class="code">EAGAIN_RD</code>, <code class="code">EAGAIN_WR</code>,
          <code class="code">Unix_error(EINTR,_,_)</code>, <code class="code">Error</code> or <code class="code">Warning</code>.<br>
</div>

<pre><span id="VALrecv"><span class="keyword">val</span> recv</span> : <code class="type"><a href="Netsys_crypto_types.TLS_PROVIDER.html#TYPEendpoint">endpoint</a> -> <a href="Netsys_types.html#TYPEmemory">Netsys_types.memory</a> -> int</code></pre><div class="info ">
<code class="code">recv ep buffer n</code>: Receives data, and puts them into the memory
          buffer, and returns the actual number of received bytes. If 0
          is returned, a close request was received by the peer. For closing
          the tunnel properly this request should be responded by another
          close request with <code class="code">bye</code> (unless this has already been done).
<p>

          May raise <code class="code">EAGAIN_RD</code>, <code class="code">EAGAIN_WR</code>,
          <code class="code">Unix_error(EINTR,_,_)</code>, <code class="code">Error</code> or <code class="code">Warning</code>.
<p>

          The exception <code class="code">TLS_switch_request</code> can only occur on the client
          side, and should be responded by <code class="code">accept_switch</code> or <code class="code">refuse_switch</code>.
<p>

          The exception <code class="code">TLS_switch_response</code> can only occur on the server
          side.<br>
</div>

<pre><span id="VALrecv_will_not_block"><span class="keyword">val</span> recv_will_not_block</span> : <code class="type"><a href="Netsys_crypto_types.TLS_PROVIDER.html#TYPEendpoint">endpoint</a> -> bool</code></pre><div class="info ">
If there is still unprocessed data in the endpoint buffer, 
          <code class="code">recv</code> is guaranteed not to block or raise <code class="code">EAGAIN</code>.<br>
</div>

<pre><span id="VALget_session_id"><span class="keyword">val</span> get_session_id</span> : <code class="type"><a href="Netsys_crypto_types.TLS_PROVIDER.html#TYPEendpoint">endpoint</a> -> string</code></pre><div class="info ">
The (non-printable) session ID<br>
</div>

<pre><span id="VALget_session_data"><span class="keyword">val</span> get_session_data</span> : <code class="type"><a href="Netsys_crypto_types.TLS_PROVIDER.html#TYPEendpoint">endpoint</a> -> string</code></pre><div class="info ">
Get the (non-printable) marshalled session data, for later resumption
          with <code class="code">resume_client</code><br>
</div>

<pre><span id="VALget_cipher_suite_type"><span class="keyword">val</span> get_cipher_suite_type</span> : <code class="type"><a href="Netsys_crypto_types.TLS_PROVIDER.html#TYPEendpoint">endpoint</a> -> string</code></pre><div class="info ">
The type of the cipher suite:<ul>
<li>"X509": X509 certificates are used</li>
<li>"OPENPGP": OpenPGP certificates are used</li>
<li>"ANON": anonymous credentials</li>
<li>"SRP": SRP credentials</li>
<li>"PSK": PSK credentials</li>
</ul>
<br>
</div>

<pre><span id="VALget_cipher_algo"><span class="keyword">val</span> get_cipher_algo</span> : <code class="type"><a href="Netsys_crypto_types.TLS_PROVIDER.html#TYPEendpoint">endpoint</a> -> string</code></pre><div class="info ">
Get the name of the cipher<br>
</div>

<pre><span id="VALget_kx_algo"><span class="keyword">val</span> get_kx_algo</span> : <code class="type"><a href="Netsys_crypto_types.TLS_PROVIDER.html#TYPEendpoint">endpoint</a> -> string</code></pre><div class="info ">
Get the name of the key exchange method<br>
</div>

<pre><span id="VALget_mac_algo"><span class="keyword">val</span> get_mac_algo</span> : <code class="type"><a href="Netsys_crypto_types.TLS_PROVIDER.html#TYPEendpoint">endpoint</a> -> string</code></pre><div class="info ">
Get the name of the message authentication code<br>
</div>

<pre><span id="VALget_compression_algo"><span class="keyword">val</span> get_compression_algo</span> : <code class="type"><a href="Netsys_crypto_types.TLS_PROVIDER.html#TYPEendpoint">endpoint</a> -> string</code></pre><div class="info ">
Get the name of the record-level compression method<br>
</div>

<pre><span id="VALget_cert_type"><span class="keyword">val</span> get_cert_type</span> : <code class="type"><a href="Netsys_crypto_types.TLS_PROVIDER.html#TYPEendpoint">endpoint</a> -> string</code></pre><div class="info ">
Get the type of the certificate<br>
</div>

<pre><span id="VALget_protocol"><span class="keyword">val</span> get_protocol</span> : <code class="type"><a href="Netsys_crypto_types.TLS_PROVIDER.html#TYPEendpoint">endpoint</a> -> string</code></pre><div class="info ">
Get the name of the tunnel protocol<br>
</div>

<pre><span id="TYPEserver_name"><span class="keyword">type</span> <code class="type"></code>server_name</span> = <code class="type">[ `Domain of string ]</code> </pre>


<pre><span id="VALget_addressed_servers"><span class="keyword">val</span> get_addressed_servers</span> : <code class="type"><a href="Netsys_crypto_types.TLS_PROVIDER.html#TYPEendpoint">endpoint</a> -><br>       <a href="Netsys_crypto_types.TLS_PROVIDER.html#TYPEserver_name">server_name</a> list</code></pre><div class="info ">
To be used in servers: The client can address one of several virtual
          servers with the SNI extension, and this function returns which
          was requested. Raises
          <code class="code">Not_found</code> if there is nothing appropriate. This information is
          only available after a handshake, and if the client submitted it.<br>
</div>

<pre><span id="VALset_session_cache"><span class="keyword">val</span> set_session_cache</span> : <code class="type">store:(string -> string -> unit) -><br>       remove:(string -> unit) -><br>       retrieve:(string -> string) -><br>       <a href="Netsys_crypto_types.TLS_PROVIDER.html#TYPEendpoint">endpoint</a> -> unit</code></pre><div class="info ">
Sets the three callbacks for storing, removing and retrieving
          sessions (on the server side)<br>
</div>

<pre><span id="VALimplementation_name"><span class="keyword">val</span> implementation_name</span> : <code class="type">string</code></pre><div class="info ">
String name of the implementation. By convention this is the
          full OCaml module path, e.g. "Nettls_gnutls.TLS"<br>
</div>

<pre><span id="VALimplementation"><span class="keyword">val</span> implementation</span> : <code class="type">unit -> exn</code></pre><div class="info ">
Implementation-defined additional functionality<br>
</div>
</body></html>