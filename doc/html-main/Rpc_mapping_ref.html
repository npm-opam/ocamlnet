<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<link rel="stylesheet" href="style.css" type="text/css">
<meta content="text/html; charset=iso-8859-1" http-equiv="Content-Type">
<link rel="Start" href="index.html">
<link rel="previous" href="Rpc_intro.html">
<link rel="next" href="Rpc_intro_gss.html">
<link rel="Up" href="index.html">
<link title="Index of types" rel=Appendix href="index_types.html">
<link title="Index of extensions" rel=Appendix href="index_extensions.html">
<link title="Index of exceptions" rel=Appendix href="index_exceptions.html">
<link title="Index of values" rel=Appendix href="index_values.html">
<link title="Index of class attributes" rel=Appendix href="index_attributes.html">
<link title="Index of class methods" rel=Appendix href="index_methods.html">
<link title="Index of classes" rel=Appendix href="index_classes.html">
<link title="Index of class types" rel=Appendix href="index_class_types.html">
<link title="Index of modules" rel=Appendix href="index_modules.html">
<link title="Index of module types" rel=Appendix href="index_module_types.html">
<link title="Uq_gtk" rel="Chapter" href="Uq_gtk.html">
<link title="Uq_tcl" rel="Chapter" href="Uq_tcl.html">
<link title="Equeue" rel="Chapter" href="Equeue.html">
<link title="Unixqueue" rel="Chapter" href="Unixqueue.html">
<link title="Unixqueue_pollset" rel="Chapter" href="Unixqueue_pollset.html">
<link title="Unixqueue_select" rel="Chapter" href="Unixqueue_select.html">
<link title="Uq_resolver" rel="Chapter" href="Uq_resolver.html">
<link title="Uq_engines" rel="Chapter" href="Uq_engines.html">
<link title="Uq_multiplex" rel="Chapter" href="Uq_multiplex.html">
<link title="Uq_transfer" rel="Chapter" href="Uq_transfer.html">
<link title="Uq_socks5" rel="Chapter" href="Uq_socks5.html">
<link title="Uq_io" rel="Chapter" href="Uq_io.html">
<link title="Uq_lwt" rel="Chapter" href="Uq_lwt.html">
<link title="Uq_libevent" rel="Chapter" href="Uq_libevent.html">
<link title="Uq_mt" rel="Chapter" href="Uq_mt.html">
<link title="Uq_client" rel="Chapter" href="Uq_client.html">
<link title="Uq_server" rel="Chapter" href="Uq_server.html">
<link title="Uq_datagram" rel="Chapter" href="Uq_datagram.html">
<link title="Uq_engines_compat" rel="Chapter" href="Uq_engines_compat.html">
<link title="Equeue_intro" rel="Chapter" href="Equeue_intro.html">
<link title="Equeue_howto" rel="Chapter" href="Equeue_howto.html">
<link title="Netcamlbox" rel="Chapter" href="Netcamlbox.html">
<link title="Netcgi_apache" rel="Chapter" href="Netcgi_apache.html">
<link title="Netcgi_modtpl" rel="Chapter" href="Netcgi_modtpl.html">
<link title="Netcgi_plex" rel="Chapter" href="Netcgi_plex.html">
<link title="Netcgi_common" rel="Chapter" href="Netcgi_common.html">
<link title="Netcgi" rel="Chapter" href="Netcgi.html">
<link title="Netcgi_ajp" rel="Chapter" href="Netcgi_ajp.html">
<link title="Netcgi_scgi" rel="Chapter" href="Netcgi_scgi.html">
<link title="Netcgi_cgi" rel="Chapter" href="Netcgi_cgi.html">
<link title="Netcgi_fcgi" rel="Chapter" href="Netcgi_fcgi.html">
<link title="Netcgi_dbi" rel="Chapter" href="Netcgi_dbi.html">
<link title="Netcgi1_compat" rel="Chapter" href="Netcgi1_compat.html">
<link title="Netcgi_test" rel="Chapter" href="Netcgi_test.html">
<link title="Netcgi_porting" rel="Chapter" href="Netcgi_porting.html">
<link title="Nethttp_client_conncache" rel="Chapter" href="Nethttp_client_conncache.html">
<link title="Nethttp_client" rel="Chapter" href="Nethttp_client.html">
<link title="Nettelnet_client" rel="Chapter" href="Nettelnet_client.html">
<link title="Netftp_data_endpoint" rel="Chapter" href="Netftp_data_endpoint.html">
<link title="Netftp_client" rel="Chapter" href="Netftp_client.html">
<link title="Nethttp_fs" rel="Chapter" href="Nethttp_fs.html">
<link title="Netftp_fs" rel="Chapter" href="Netftp_fs.html">
<link title="Netsmtp" rel="Chapter" href="Netsmtp.html">
<link title="Netpop" rel="Chapter" href="Netpop.html">
<link title="Netldap" rel="Chapter" href="Netldap.html">
<link title="Netclient_tut" rel="Chapter" href="Netclient_tut.html">
<link title="Netgss_bindings" rel="Chapter" href="Netgss_bindings.html">
<link title="Netgss" rel="Chapter" href="Netgss.html">
<link title="Nethttpd_types" rel="Chapter" href="Nethttpd_types.html">
<link title="Nethttpd_kernel" rel="Chapter" href="Nethttpd_kernel.html">
<link title="Nethttpd_reactor" rel="Chapter" href="Nethttpd_reactor.html">
<link title="Nethttpd_engine" rel="Chapter" href="Nethttpd_engine.html">
<link title="Nethttpd_services" rel="Chapter" href="Nethttpd_services.html">
<link title="Nethttpd_plex" rel="Chapter" href="Nethttpd_plex.html">
<link title="Nethttpd_util" rel="Chapter" href="Nethttpd_util.html">
<link title="Nethttpd_intro" rel="Chapter" href="Nethttpd_intro.html">
<link title="Netmcore" rel="Chapter" href="Netmcore.html">
<link title="Netmcore_camlbox" rel="Chapter" href="Netmcore_camlbox.html">
<link title="Netmcore_mempool" rel="Chapter" href="Netmcore_mempool.html">
<link title="Netmcore_heap" rel="Chapter" href="Netmcore_heap.html">
<link title="Netmcore_ref" rel="Chapter" href="Netmcore_ref.html">
<link title="Netmcore_array" rel="Chapter" href="Netmcore_array.html">
<link title="Netmcore_sem" rel="Chapter" href="Netmcore_sem.html">
<link title="Netmcore_mutex" rel="Chapter" href="Netmcore_mutex.html">
<link title="Netmcore_condition" rel="Chapter" href="Netmcore_condition.html">
<link title="Netmcore_queue" rel="Chapter" href="Netmcore_queue.html">
<link title="Netmcore_buffer" rel="Chapter" href="Netmcore_buffer.html">
<link title="Netmcore_matrix" rel="Chapter" href="Netmcore_matrix.html">
<link title="Netmcore_hashtbl" rel="Chapter" href="Netmcore_hashtbl.html">
<link title="Netmcore_process" rel="Chapter" href="Netmcore_process.html">
<link title="Netmcore_tut" rel="Chapter" href="Netmcore_tut.html">
<link title="Netmcore_basics" rel="Chapter" href="Netmcore_basics.html">
<link title="Netplex_types" rel="Chapter" href="Netplex_types.html">
<link title="Netplex_mp" rel="Chapter" href="Netplex_mp.html">
<link title="Netplex_mt" rel="Chapter" href="Netplex_mt.html">
<link title="Netplex_log" rel="Chapter" href="Netplex_log.html">
<link title="Netplex_controller" rel="Chapter" href="Netplex_controller.html">
<link title="Netplex_container" rel="Chapter" href="Netplex_container.html">
<link title="Netplex_sockserv" rel="Chapter" href="Netplex_sockserv.html">
<link title="Netplex_workload" rel="Chapter" href="Netplex_workload.html">
<link title="Netplex_main" rel="Chapter" href="Netplex_main.html">
<link title="Netplex_config" rel="Chapter" href="Netplex_config.html">
<link title="Netplex_kit" rel="Chapter" href="Netplex_kit.html">
<link title="Rpc_netplex" rel="Chapter" href="Rpc_netplex.html">
<link title="Netplex_cenv" rel="Chapter" href="Netplex_cenv.html">
<link title="Netplex_semaphore" rel="Chapter" href="Netplex_semaphore.html">
<link title="Netplex_sharedvar" rel="Chapter" href="Netplex_sharedvar.html">
<link title="Netplex_mutex" rel="Chapter" href="Netplex_mutex.html">
<link title="Netplex_encap" rel="Chapter" href="Netplex_encap.html">
<link title="Netplex_mbox" rel="Chapter" href="Netplex_mbox.html">
<link title="Netplex_internal" rel="Chapter" href="Netplex_internal.html">
<link title="Netplex_intro" rel="Chapter" href="Netplex_intro.html">
<link title="Netplex_advanced" rel="Chapter" href="Netplex_advanced.html">
<link title="Netplex_admin" rel="Chapter" href="Netplex_admin.html">
<link title="Netshm" rel="Chapter" href="Netshm.html">
<link title="Netshm_data" rel="Chapter" href="Netshm_data.html">
<link title="Netshm_hashtbl" rel="Chapter" href="Netshm_hashtbl.html">
<link title="Netshm_array" rel="Chapter" href="Netshm_array.html">
<link title="Netshm_intro" rel="Chapter" href="Netshm_intro.html">
<link title="Netstring_pcre" rel="Chapter" href="Netstring_pcre.html">
<link title="Netconversion" rel="Chapter" href="Netconversion.html">
<link title="Netchannels" rel="Chapter" href="Netchannels.html">
<link title="Netstream" rel="Chapter" href="Netstream.html">
<link title="Netmime_string" rel="Chapter" href="Netmime_string.html">
<link title="Netmime" rel="Chapter" href="Netmime.html">
<link title="Netsendmail" rel="Chapter" href="Netsendmail.html">
<link title="Neturl" rel="Chapter" href="Neturl.html">
<link title="Netaddress" rel="Chapter" href="Netaddress.html">
<link title="Netbuffer" rel="Chapter" href="Netbuffer.html">
<link title="Netmime_header" rel="Chapter" href="Netmime_header.html">
<link title="Netmime_channels" rel="Chapter" href="Netmime_channels.html">
<link title="Neturl_ldap" rel="Chapter" href="Neturl_ldap.html">
<link title="Netdate" rel="Chapter" href="Netdate.html">
<link title="Netencoding" rel="Chapter" href="Netencoding.html">
<link title="Netulex" rel="Chapter" href="Netulex.html">
<link title="Netaccel" rel="Chapter" href="Netaccel.html">
<link title="Netaccel_link" rel="Chapter" href="Netaccel_link.html">
<link title="Nethtml" rel="Chapter" href="Nethtml.html">
<link title="Netstring_str" rel="Chapter" href="Netstring_str.html">
<link title="Netmappings" rel="Chapter" href="Netmappings.html">
<link title="Netaux" rel="Chapter" href="Netaux.html">
<link title="Nethttp" rel="Chapter" href="Nethttp.html">
<link title="Netpagebuffer" rel="Chapter" href="Netpagebuffer.html">
<link title="Netfs" rel="Chapter" href="Netfs.html">
<link title="Netglob" rel="Chapter" href="Netglob.html">
<link title="Netauth" rel="Chapter" href="Netauth.html">
<link title="Netsockaddr" rel="Chapter" href="Netsockaddr.html">
<link title="Netnumber" rel="Chapter" href="Netnumber.html">
<link title="Netxdr_mstring" rel="Chapter" href="Netxdr_mstring.html">
<link title="Netxdr" rel="Chapter" href="Netxdr.html">
<link title="Netcompression" rel="Chapter" href="Netcompression.html">
<link title="Netunichar" rel="Chapter" href="Netunichar.html">
<link title="Netasn1" rel="Chapter" href="Netasn1.html">
<link title="Netasn1_encode" rel="Chapter" href="Netasn1_encode.html">
<link title="Netoid" rel="Chapter" href="Netoid.html">
<link title="Netstring_tstring" rel="Chapter" href="Netstring_tstring.html">
<link title="Netdn" rel="Chapter" href="Netdn.html">
<link title="Netx509" rel="Chapter" href="Netx509.html">
<link title="Netascii_armor" rel="Chapter" href="Netascii_armor.html">
<link title="Nettls_support" rel="Chapter" href="Nettls_support.html">
<link title="Netmech_scram" rel="Chapter" href="Netmech_scram.html">
<link title="Netmech_scram_gssapi" rel="Chapter" href="Netmech_scram_gssapi.html">
<link title="Netmech_scram_sasl" rel="Chapter" href="Netmech_scram_sasl.html">
<link title="Netmech_scram_http" rel="Chapter" href="Netmech_scram_http.html">
<link title="Netgssapi_support" rel="Chapter" href="Netgssapi_support.html">
<link title="Netgssapi_auth" rel="Chapter" href="Netgssapi_auth.html">
<link title="Netchannels_crypto" rel="Chapter" href="Netchannels_crypto.html">
<link title="Netx509_pubkey" rel="Chapter" href="Netx509_pubkey.html">
<link title="Netx509_pubkey_crypto" rel="Chapter" href="Netx509_pubkey_crypto.html">
<link title="Netsaslprep" rel="Chapter" href="Netsaslprep.html">
<link title="Netmech_plain_sasl" rel="Chapter" href="Netmech_plain_sasl.html">
<link title="Netmech_crammd5_sasl" rel="Chapter" href="Netmech_crammd5_sasl.html">
<link title="Netmech_digest_sasl" rel="Chapter" href="Netmech_digest_sasl.html">
<link title="Netmech_digest_http" rel="Chapter" href="Netmech_digest_http.html">
<link title="Netmech_krb5_sasl" rel="Chapter" href="Netmech_krb5_sasl.html">
<link title="Netmech_gs2_sasl" rel="Chapter" href="Netmech_gs2_sasl.html">
<link title="Netmech_spnego_http" rel="Chapter" href="Netmech_spnego_http.html">
<link title="Netchannels_tut" rel="Chapter" href="Netchannels_tut.html">
<link title="Netmime_tut" rel="Chapter" href="Netmime_tut.html">
<link title="Netsendmail_tut" rel="Chapter" href="Netsendmail_tut.html">
<link title="Netulex_tut" rel="Chapter" href="Netulex_tut.html">
<link title="Neturl_tut" rel="Chapter" href="Neturl_tut.html">
<link title="Netsys" rel="Chapter" href="Netsys.html">
<link title="Netsys_posix" rel="Chapter" href="Netsys_posix.html">
<link title="Netsys_pollset" rel="Chapter" href="Netsys_pollset.html">
<link title="Netlog" rel="Chapter" href="Netlog.html">
<link title="Netexn" rel="Chapter" href="Netexn.html">
<link title="Netsys_win32" rel="Chapter" href="Netsys_win32.html">
<link title="Netsys_pollset_posix" rel="Chapter" href="Netsys_pollset_posix.html">
<link title="Netsys_pollset_win32" rel="Chapter" href="Netsys_pollset_win32.html">
<link title="Netsys_pollset_generic" rel="Chapter" href="Netsys_pollset_generic.html">
<link title="Netsys_signal" rel="Chapter" href="Netsys_signal.html">
<link title="Netsys_oothr" rel="Chapter" href="Netsys_oothr.html">
<link title="Netsys_xdr" rel="Chapter" href="Netsys_xdr.html">
<link title="Netsys_rng" rel="Chapter" href="Netsys_rng.html">
<link title="Netsys_crypto_types" rel="Chapter" href="Netsys_crypto_types.html">
<link title="Netsys_types" rel="Chapter" href="Netsys_types.html">
<link title="Netsys_mem" rel="Chapter" href="Netsys_mem.html">
<link title="Netsys_tmp" rel="Chapter" href="Netsys_tmp.html">
<link title="Netsys_sem" rel="Chapter" href="Netsys_sem.html">
<link title="Netsys_pmanage" rel="Chapter" href="Netsys_pmanage.html">
<link title="Netsys_crypto" rel="Chapter" href="Netsys_crypto.html">
<link title="Netsys_tls" rel="Chapter" href="Netsys_tls.html">
<link title="Netsys_ciphers" rel="Chapter" href="Netsys_ciphers.html">
<link title="Netsys_digests" rel="Chapter" href="Netsys_digests.html">
<link title="Netsys_crypto_modes" rel="Chapter" href="Netsys_crypto_modes.html">
<link title="Netsys_gssapi" rel="Chapter" href="Netsys_gssapi.html">
<link title="Netsys_sasl_types" rel="Chapter" href="Netsys_sasl_types.html">
<link title="Netsys_sasl" rel="Chapter" href="Netsys_sasl.html">
<link title="Netsys_polypipe" rel="Chapter" href="Netsys_polypipe.html">
<link title="Netsys_polysocket" rel="Chapter" href="Netsys_polysocket.html">
<link title="Netsys_global" rel="Chapter" href="Netsys_global.html">
<link title="Nettls_gnutls_bindings" rel="Chapter" href="Nettls_gnutls_bindings.html">
<link title="Nettls_nettle_bindings" rel="Chapter" href="Nettls_nettle_bindings.html">
<link title="Nettls_gnutls" rel="Chapter" href="Nettls_gnutls.html">
<link title="Netunidata" rel="Chapter" href="Netunidata.html">
<link title="Netgzip" rel="Chapter" href="Netgzip.html">
<link title="Rpc_auth_local" rel="Chapter" href="Rpc_auth_local.html">
<link title="Rpc_xti_client" rel="Chapter" href="Rpc_xti_client.html">
<link title="Rpc" rel="Chapter" href="Rpc.html">
<link title="Rpc_program" rel="Chapter" href="Rpc_program.html">
<link title="Rpc_util" rel="Chapter" href="Rpc_util.html">
<link title="Rpc_portmapper_aux" rel="Chapter" href="Rpc_portmapper_aux.html">
<link title="Rpc_packer" rel="Chapter" href="Rpc_packer.html">
<link title="Rpc_transport" rel="Chapter" href="Rpc_transport.html">
<link title="Rpc_client" rel="Chapter" href="Rpc_client.html">
<link title="Rpc_simple_client" rel="Chapter" href="Rpc_simple_client.html">
<link title="Rpc_portmapper_clnt" rel="Chapter" href="Rpc_portmapper_clnt.html">
<link title="Rpc_portmapper" rel="Chapter" href="Rpc_portmapper.html">
<link title="Rpc_server" rel="Chapter" href="Rpc_server.html">
<link title="Rpc_auth_sys" rel="Chapter" href="Rpc_auth_sys.html">
<link title="Rpc_auth_gssapi" rel="Chapter" href="Rpc_auth_gssapi.html">
<link title="Rpc_proxy" rel="Chapter" href="Rpc_proxy.html">
<link title="Rpc_intro" rel="Chapter" href="Rpc_intro.html">
<link title="Rpc_mapping_ref" rel="Chapter" href="Rpc_mapping_ref.html">
<link title="Rpc_intro_gss" rel="Chapter" href="Rpc_intro_gss.html">
<link title="Shell_sys" rel="Chapter" href="Shell_sys.html">
<link title="Shell" rel="Chapter" href="Shell.html">
<link title="Shell_uq" rel="Chapter" href="Shell_uq.html">
<link title="Shell_fs" rel="Chapter" href="Shell_fs.html">
<link title="Shell_intro" rel="Chapter" href="Shell_intro.html">
<link title="Intro" rel="Chapter" href="Intro.html">
<link title="Platform" rel="Chapter" href="Platform.html">
<link title="Foreword" rel="Chapter" href="Foreword.html">
<link title="Ipv6" rel="Chapter" href="Ipv6.html">
<link title="Regexp" rel="Chapter" href="Regexp.html">
<link title="Tls" rel="Chapter" href="Tls.html">
<link title="Crypto" rel="Chapter" href="Crypto.html">
<link title="Authentication" rel="Chapter" href="Authentication.html">
<link title="Credentials" rel="Chapter" href="Credentials.html">
<link title="Gssapi" rel="Chapter" href="Gssapi.html">
<link title="Ocamlnet4" rel="Chapter" href="Ocamlnet4.html">
<link title="Get" rel="Chapter" href="Get.html"><link title="RPC Language Mapping Reference" rel="Section" href="#1_RPCLanguageMappingReference">
<link title="Representation Levels" rel="Subsection" href="#2_RepresentationLevels">
<link title="XDR: Simple Types" rel="Subsection" href="#2_XDRSimpleTypes">
<link title="XDR: Options" rel="Subsection" href="#2_XDROptions">
<link title="XDR: Arrays" rel="Subsection" href="#2_XDRArrays">
<link title="XDR: Structs" rel="Subsection" href="#2_XDRStructs">
<link title="XDR: Enumerations" rel="Subsection" href="#2_XDREnumerations">
<link title="XDR: Unions discriminated by integers" rel="Subsection" href="#2_XDRUnionsdiscriminatedbyintegers">
<link title="XDR: Unions discriminated by enumerations" rel="Subsection" href="#2_XDRUnionsdiscriminatedbyenumerations">
<link title="RPC: Programs" rel="Subsection" href="#2_RPCPrograms">
<link title="RPC: Clients" rel="Subsection" href="#2_RPCClients">
<link title="RPC: Servers" rel="Subsection" href="#2_RPCServers">
<title>Ocamlnet 4 Reference Manual : Rpc_mapping_ref</title>
</head>
<body>
<div class="navbar"><a class="pre" href="Rpc_intro.html" title="Rpc_intro">Previous</a>
&nbsp;<a class="up" href="index.html" title="Index">Up</a>
&nbsp;<a class="post" href="Rpc_intro_gss.html" title="Rpc_intro_gss">Next</a>
</div>
<h1>Rpc_mapping_ref</h1>
<br>
<h1 id="1_RPCLanguageMappingReference">RPC Language Mapping Reference</h1>
<p>

The OncRPC (alias SunRPC) standard consists of two parts, namely the
external data representation (XDR) and the RPC protocol. They are 
defined in RFC 1831 and RFC 1832.
<p>

In this document we describe how the various parts of XDR and RPC
are mapped to the Objective Caml language.
<p>

<h2 id="2_RepresentationLevels">Representation Levels</h2>
<p>

The transformation of binary XDR messages to O'Caml values is done in
several steps, corresponding to several ways of representing the values:
<p>
<ul>
<li>Binary level: The message is represented as byte string. In O'Caml,
  these byte strings are always <code class="code">string</code> values.</li>
<li>Term level: The XDR type is given as <a href="Netxdr.html#VALxdr_type_term"><code class="code">Netxdr.xdr_type_term</code></a>.
  The message is represented as structured <a href="Netxdr.html#TYPExdr_value"><code class="code">Netxdr.xdr_value</code></a>
  term. For example, an XDR <code class="code">struct</code> with two components <code class="code">a</code> and <code class="code">b</code>
  with integer values 1 and 2 is represented as
  <pre class="codepre"><code class="code">XV_struct [ "a", XV_int r1; "b" XV_int r2 ]</code></pre> where
  <code class="code">r1 = Netnumber.int4_of_int 1</code> and <code class="code">r2 = Netnumber.int4_of_int 2</code>. There
  are sometimes several ways of representing a value on term level.</li>
<li>Fully-mapped level: The message is represented as a generated O'Caml type
  that closely corresponds to the XDR type. The <code class="code">struct</code> example
  would use the type <pre class="codepre"><code class="code">type name = { a : int; b : int }</code></pre>. Some details
  can be selected by the user, e.g. how integers are represented.
  The types are generated using <code class="code">ocamlrpcgen</code>.</li>
</ul>

The tool <code class="code">ocamlrpcgen</code> can be invoked on an input file <code class="code">name.x</code> with
different switches to create three modules: the type mapper
<code class="code">Name_aux</code>, the RPC client <code class="code">Name_clnt</code> and the RPC server <code class="code">Name_srv</code>.
The type mapper module mainly contains the necessary definitions to
convert values between the representation levels.
<p>

In particular, the type mapper module contains for every XDR type <i>t</i>
several definitions:
<p>
<ul>
<li>The definition of the O'Caml type corresponding to <i>t</i> on the
  fully-mapped level.</li>
<li>The dynamic representation of the XDR type as <a href="Netxdr.html#VALxdr_type_term"><code class="code">Netxdr.xdr_type_term</code></a>.
  This definition is named <code class="code">xdrt_</code><i>t</i>. The type term is required to
  convert a binary message to a value on term level. The conversion
  functions to do so are available in the <a href="Netxdr.html"><code class="code">Netxdr</code></a> module.</li>
<li>The conversion function <code class="code">_of_</code><i>t</i> that turns a fully-mapped
  value into a term value represented as <a href="Netxdr.html#TYPExdr_value"><code class="code">Netxdr.xdr_value</code></a>.</li>
<li>The conversion function <code class="code">_to_</code><i>t</i> that turns a term value
  to a fully-mapped value.</li>
</ul>

In order to develop an RPC client or server it is usually not necessary
to use these definitions. They are useful, however, to
encode or decode binary XDR messages directly (e.g. outside an RPC
context).
<p>

<h2 id="2_XDRSimpleTypes">XDR: Simple Types</h2>
<p>

The following table shows:<ul>
<li>how a variable <code class="code">x</code> would be declared in the XDR file</li>
<li>what the corresponding term type is</li>
<li>how the type is mapped to a full OCaml type</li>
</ul>

<table class="t1">
<tr class="t1head">
<td class="t1">XDR declaration for <code class="code">x</code></td>
<td class="t1">Term-level mapping</td>
<td class="t1">Full mapping</td>
<td class="t1">Comment</td>
</tr>
<tr class="t1">
<td class="t1"><code class="code">void</code></td>
<td class="t1"><code class="code">Netxdr.X_void</code></td>
<td class="t1"><code class="code">unit</code> (in some contexts omitted)</td>
<td class="t1">-</td>
</tr>
<tr class="t1">
<td class="t1"><code class="code">int x</code></td>
<td class="t1"><code class="code">Netxdr.X_int</code></td>
<td class="t1"><a href="Netnumber.html#TYPEint4"><code class="code">Netnumber.int4</code></a>, <code class="code">int32</code>, <code class="code">int64</code>, or <code class="code">int</code> [1]</td>
<td class="t1">32 bit signed integer</td>
</tr>
<tr class="t1">
<td class="t1"><code class="code">_abstract int x</code></td>
<td class="t1"><code class="code">Netxdr.X_int</code></td>
<td class="t1"><a href="Netnumber.html#TYPEint4"><code class="code">Netnumber.int4</code></a> [6]</td>
<td class="t1">32 bit signed integer</td>
</tr>
<tr class="t1">
<td class="t1"><code class="code">_int32 int x</code></td>
<td class="t1"><code class="code">Netxdr.X_int</code></td>
<td class="t1"><code class="code">int32</code></td>
<td class="t1">32 bit signed integer</td>
</tr>
<tr class="t1">
<td class="t1"><code class="code">_int64 int x</code></td>
<td class="t1"><code class="code">Netxdr.X_int</code></td>
<td class="t1"><code class="code">int64</code></td>
<td class="t1">32 bit signed integer</td>
</tr>
<tr class="t1">
<td class="t1"><code class="code">_unboxed int x</code></td>
<td class="t1"><code class="code">Netxdr.X_int</code></td>
<td class="t1"><code class="code">int</code> [2]</td>
<td class="t1">32 bit signed integer</td>
</tr>
<tr class="t1">
<td class="t1"><code class="code">unsigned int x</code></td>
<td class="t1"><code class="code">Netxdr.X_uint</code></td>
<td class="t1"><a href="Netnumber.html#TYPEuint4"><code class="code">Netnumber.uint4</code></a>, <code class="code">int32</code>, <code class="code">int64</code>, or <code class="code">int</code> [1]</td>
<td class="t1">32 bit unsigned integer</td>
</tr>
<tr class="t1">
<td class="t1"><code class="code">unsigned _abstract int x</code></td>
<td class="t1"><code class="code">Netxdr.X_uint</code></td>
<td class="t1"><a href="Netnumber.html#TYPEuint4"><code class="code">Netnumber.uint4</code></a> [6]</td>
<td class="t1">32 bit unsigned integer</td>
</tr>
<tr class="t1">
<td class="t1"><code class="code">unsigned _int32 int x</code></td>
<td class="t1"><code class="code">Netxdr.X_uint</code></td>
<td class="t1"><code class="code">int32</code> [4]</td>
<td class="t1">32 bit unsigned integer</td>
</tr>
<tr class="t1">
<td class="t1"><code class="code">unsigned _int64 int x</code></td>
<td class="t1"><code class="code">Netxdr.X_uint</code></td>
<td class="t1"><code class="code">int64</code></td>
<td class="t1">32 bit unsigned integer</td>
</tr>
<tr class="t1">
<td class="t1"><code class="code">unsigned _unboxed int x</code></td>
<td class="t1"><code class="code">Netxdr.X_uint</code></td>
<td class="t1"><code class="code">int</code> [2]</td>
<td class="t1">32 bit unsigned integer</td>
</tr>
<tr class="t1">
<td class="t1"><code class="code">hyper x</code></td>
<td class="t1"><code class="code">Netxdr.X_hyper</code></td>
<td class="t1"><a href="Netnumber.html#TYPEint8"><code class="code">Netnumber.int8</code></a>, <code class="code">int64</code>, or <code class="code">int</code> [1]</td>
<td class="t1">64 bit signed integer</td>
</tr>
<tr class="t1">
<td class="t1"><code class="code">_abstract hyper x</code></td>
<td class="t1"><code class="code">Netxdr.X_hyper</code></td>
<td class="t1"><a href="Netnumber.html#TYPEint8"><code class="code">Netnumber.int8</code></a> [6]</td>
<td class="t1">64 bit signed integer</td>
</tr>
<tr class="t1">
<td class="t1"><code class="code">_int64 hyper x</code></td>
<td class="t1"><code class="code">Netxdr.X_hyper</code></td>
<td class="t1"><code class="code">int64</code></td>
<td class="t1">64 bit signed integer</td>
</tr>
<tr class="t1">
<td class="t1"><code class="code">_unboxed hyper x</code></td>
<td class="t1"><code class="code">Netxdr.X_hyper</code></td>
<td class="t1"><code class="code">int</code> [3]</td>
<td class="t1">64 bit signed integer</td>
</tr>
<tr class="t1">
<td class="t1"><code class="code">unsigned hyper x</code></td>
<td class="t1"><code class="code">Netxdr.X_uhyper</code></td>
<td class="t1"><a href="Netnumber.html#TYPEint8"><code class="code">Netnumber.int8</code></a>, <code class="code">int64</code>, or <code class="code">int</code> [1]</td>
<td class="t1">64 bit unsigned integer</td>
</tr>
<tr class="t1">
<td class="t1"><code class="code">unsigned _abstract hyper x</code></td>
<td class="t1"><code class="code">Netxdr.X_uhyper</code></td>
<td class="t1"><a href="Netnumber.html#TYPEuint8"><code class="code">Netnumber.uint8</code></a> [6]</td>
<td class="t1">64 bit unsigned integer</td>
</tr>
<tr class="t1">
<td class="t1"><code class="code">unsigned _int64 hyper x</code></td>
<td class="t1"><code class="code">Netxdr.X_uhyper</code></td>
<td class="t1"><code class="code">int64</code> [4]</td>
<td class="t1">64 bit unsigned integer</td>
</tr>
<tr class="t1">
<td class="t1"><code class="code">unsigned _unboxed hyper x</code></td>
<td class="t1"><code class="code">Netxdr.X_uhyper</code></td>
<td class="t1"><code class="code">int</code> [3]</td>
<td class="t1">64 bit unsigned integer</td>
</tr>
<tr class="t1">
<td class="t1"><code class="code">bool x</code></td>
<td class="t1"><a href="Netxdr.html#VALx_bool"><code class="code">Netxdr.x_bool</code></a>
<td class="t1"><code class="code">bool</code></td>
<td class="t1">Boolean type</td>
</tr>
<tr class="t1">
<td class="t1"><code class="code">float x</code></td>
<td class="t1"><code class="code">Netxdr.X_float</code></td>
<td class="t1"><code class="code">float</code> [5]</td>
<td class="t1">32 bit IEEE float</td>
</tr>
<tr class="t1">
<td class="t1"><code class="code">double x</code></td>
<td class="t1"><code class="code">Netxdr.X_double</code></td>
<td class="t1"><code class="code">float</code> [5]</td>
<td class="t1">64 bit IEEE float</td>
</tr>
<tr class="t1">
<td class="t1"><code class="code">opaque x[n]</code></td>
<td class="t1"><code class="code">Netxdr.X_opaque_fixed</code></td>
<td class="t1"><code class="code">string</code></td>
<td class="t1">Opaque data with exactly <code class="code">n</code> bytes.
The length <code class="code">n</code> is dynamically checked</td>
</tr>
<tr class="t1">
<td class="t1"><code class="code">opaque x&lt;n&gt;</code></td>
<td class="t1"><code class="code">Netxdr.X_opaque</code></td>
<td class="t1"><code class="code">string</code></td>
<td class="t1">Opaque data with up to <code class="code">n</code> bytes.
The length <code class="code">n</code> is dynamically checked</td>
</tr>
<tr class="t1">
<td class="t1"><code class="code">string x&lt;n&gt;</code></td>
<td class="t1"><code class="code">Netxdr.X_string</code></td>
<td class="t1"><code class="code">string</code></td>
<td class="t1">String consisting of up to <code class="code">n</code> bytes.
The length <code class="code">n</code> is dynamically checked</td>
</td>
</tr>
<tr class="t1">
<td class="t1"><code class="code">_managed string x&lt;n&gt;</code></td>
<td class="t1"><code class="code">Netxdr.X_mstring</code></td>
<td class="t1"><a href="Netxdr_mstring.mstring-c.html"><code class="code">Netxdr_mstring.mstring</code></a></td>
<td class="t1">Alternative runtime representation. See <a href="Netxdr_mstring.html"><code class="code">Netxdr_mstring</code></a>.</td>
</tr>
</table>
<p>

Footnotes:<OL>
<li> The default is the first alternative. You can select with
    command-line switches of <code class="code">ocamlrpcgen</code> one of the other
    options for the whole XDR file</li>
<li> On 32 bit platforms only a subset of XDR values can be represented 
    with this OCaml type. If a conversion fails, <a href="Netnumber.html#EXCEPTIONCannot_represent"><code class="code">Netnumber.Cannot_represent</code></a>
    is raised.</li>
<li> On both 32 and 64 bit platforms only a subset of XDR values can be
    represented 
    with this OCaml type. If a conversion fails, <a href="Netnumber.html#EXCEPTIONCannot_represent"><code class="code">Netnumber.Cannot_represent</code></a>
    is raised.</li>
<li> This is a logical mapping: large XDR numbers where the MSB is set
    are mapped to negative OCaml numbers.</li>
<li> The OCaml <code class="code">float</code> type is a 64 bit IEEE floating point number.</li>
<li> The module <a href="Netnumber.html"><code class="code">Netnumber</code></a> is an extended version of the older
    (and now removed) <code class="code">Rtypes</code> definition, and contains wrapper types for all
    XDR number types.</li>
</OL>

<h2 id="2_XDROptions">XDR: Options</h2>
<p>

The "pointer type" <code class="code">*t</code> is considered as an option type in XDR
corresponding to <code class="code">option</code> in O'Caml, i.e. a variant with the two
cases that an argument is missing or present. Option types are
written <pre class="codepre"><code class="code">t *varname</code></pre> in .x files.
<p>

On term level, the missing argument value is represented as 
<a href="Netxdr.html#VALxv_none"><code class="code">Netxdr.xv_none</code></a>. The present argument value is represented as
<a href="Netxdr.html#VALxv_some"><code class="code">Netxdr.xv_some</code></a> <code class="code">v</code> when <code class="code">v</code> is the mapped argument value. Actually,
<code class="code">xv_none</code> and <code class="code">xv_some</code> construct XDR terms that are unions over
the boolean enumeration as discriminator.
<p>

On the fully-mapped level, the option type is mapped to
<pre class="codepre"><code class="code">t' option</code></pre> O'Caml type when <code class="code">t'</code> is the mapped argument type.
<p>

<h2 id="2_XDRArrays">XDR: Arrays</h2>
<p>

In XDR arrays are formed over an element type. Furthermore, there may
be the size constraint that exactly or at most n elements are
contained in the array. If the size constraint is missing, the array
may have arbitrary many elements. However, due to the binary
representation, the number is actually limited to 2 ^ 32 - 1.
<p>

<table class="t1">
<tr class="t1head">
<td class="t1">XDR declaration for <code class="code">x</code><code class="code">  </code></td>
<td class="t1">Term-level mapping<code class="code">  </code></td>
<td class="t1">Full mapping<code class="code">  </code></td>
<td class="t1">Comment</td>
</tr>
<tr class="t1">
<td class="t1"><code class="code">t x[n]</code></td>
<td class="t1"><code class="code">Netxdr.X_array</code></td>
<td class="t1"><code class="code">t' array</code></td>
<td class="t1">Arrays with exactly <code class="code">n</code> elements</td>
</tr>
<tr class="t1">
<td class="t1"><code class="code">t x&lt;n&gt;</code></td>
<td class="t1"><code class="code">Netxdr.X_array</code></td>
<td class="t1"><code class="code">t' array</code></td>
<td class="t1">Arrays with up to <code class="code">n</code> elements</td>
</tr>
<tr class="t1">
<td class="t1"><code class="code">t x&lt;&gt;</code></td>
<td class="t1"><code class="code">Netxdr.X_array</code></td>
<td class="t1"><code class="code">t' array</code></td>
<td class="t1">Arrays with any number of elements</td>
</tr>
</table>
<p>

The size constraints are dynamically checked in all cases when RPC
message are analyzed or created.
<p>

<h2 id="2_XDRStructs">XDR: Structs</h2>
<p>

Structs are products with named components, like record types in O'Caml.
The components have, in addition to their name, a fixed order, 
because the order of the components determines the order in the
binary message format. That means that the components can be accessed
by two methods: by name and by index.
<p>

Struct are written as
<pre class="codepre"><code class="code"> struct {
     t0 varname0;
     t1 varname1;
     ...
  }
</code></pre> in .x files.
<p>

For example, <code class="code"> struct { int a; hyper b } </code> means a struct with two
components. At position 0 we find "a", and at position 1 we find "b".
Of course, this type is different from <code class="code"> struct { hyper b; int a } </code>
because the order of the components is essential.
<p>

On term level, there are two ways of representing structs <code class="code">Netxdr.X_struct</code>: one
identifies components by name, one by position. The latter is also
called the "fast" representation (and the one used by <code class="code">ocamlrpcgen</code>).
<p>

In the "by name" case, the struct value is represented as
<code class="code">Netxdr.XV_struct</code> <code class="code">components</code> where <code class="code">components</code> is an association
list <code class="code">[(c0_name, c0_val); (c1_name, c1_val); ...]</code> where
<code class="code">cK_name</code> are the names of the components and <code class="code">cK_val</code> their
actual values as terms. The order of the components can be arbitrary.
<p>

In the "by position" case, the struct value is represented as
<code class="code">Netxdr.XV_struct_fast</code> <code class="code">components</code> where <code class="code">components</code> is an 
array of terms such that <code class="code">components.(k)</code> is the term value of
the <code class="code">k</code>-th component.
<p>

On the fully-mapped level, the struct is mapped to an O'Caml record.
The order of the components remains the same, but the names of
the components may be modified. First, the names are modified such
that they are valid component names in O'Caml by ensuring that the
first letter is lowercase. Second, the names may be changed because
several structs use the same component names which is not possible
in O'Caml. Thus, the generated O'Caml record type look like
<p>

<pre class="codepre"><code class="code">   {
     mutable varname0' : t0';
     mutable varname1' : t1';
     ...
   }
</code></pre>
<p>

where <code class="code">varnameK'</code> is the component name after the mentioned renaming
and <code class="code">tK'</code> is the mapped component type, both for position <code class="code">K</code>.
<p>

<h3 id="3_Equalityconstraints">Equality constraints</h3>
<p>

Since Ocamlnet-3.6.7 the keyword <code class="code">_equals</code> is understood and
generates an equality constraint, e.g.
<code class="code">struct _equals "M.t" { int a; hyper b }</code>, meaning that this OCaml
record type is the same as the one defined as <code class="code">M.t</code>.
<p>

<h3 id="3_Controllingthenamemapping">Controlling the name mapping</h3>
<p>

Ocamlnet-3.6.7 also introduces the name mapping directives for
struct fields:
<p>
<ul>
<li><code class="code">_lowercase</code>: the XDR name is lowercased</li>
<li><code class="code">_uppercase</code>: the XDR name is uppercased</li>
<li><code class="code">_capitalize</code>: the XDR name is capitalized</li>
<li><code class="code">_prefix "p"</code>: this prefix is prepended to the XDR name</li>
</ul>

For example, <code class="code">struct _lowercase _prefix "my_" { int A; hyper B }</code>
would generate a record type with fields <code class="code">my_a</code> and <code class="code">my_b</code>.
<p>

<h3 id="3_Tuples">Tuples</h3>
<p>

Since Ocamlnet-3.6.7 it is possible to select an alternate mapping
to OCaml tuples by specifying the <code class="code">_tuple</code> keyword (e.g.
<code class="code"> struct _tuple { int a; hyper b } </code>).
<p>

<h2 id="2_XDREnumerations">XDR: Enumerations</h2>
<p>

In XDR it is possible to define enumerations which are considered as
subtypes of <code class="code">int</code>. These consist of a list of integers with associated
symbolic names. In the .x file this is written as
<p>

<pre class="codepre"><code class="code">   enum {
     Name0 = Int0,
     Name1 = Int1,
     ...
   }
</code></pre>
<p>

where <code class="code">NameK</code> are identifiers and <code class="code">IntK</code> are literal numbers.
<p>

In this section we only consider the case that the enumerations are 
not used as discriminator for a union. (See below for the other case.)
<p>

On term level, there are again two representations. One uses the
names to identify one of the enumerated values, and the other
uses a positional method.
<p>

In the "by name" case, the value named <code class="code">NameK</code> is represented as
<code class="code">Netxdr.XV_enum "NameK"</code>, i.e. the name is the argument of <code class="code">XV_enum</code>.
<p>

In the "by position" case, the value named <code class="code">NameK</code> is represented as
<code class="code">Netxdr.XV_enum_fast K</code>, i.e. the position in the enum declaration is
the argument of <code class="code">XV_enum</code>.
<p>

On the fully-mapped level, the enumerated value named <code class="code">NameK</code> is
represented as O'Caml value of type <code class="code">Netnumber.int4</code> whose value is
<code class="code">IntK</code>, i.e. the number associated with the name. In the type mapper
file generated by <code class="code">ocamlrpcgen</code> there are additional definitions
for every enum. In particular, there is a constant whose name
is <code class="code">NameK</code> (after makeing the name OCamlish) and whose value is
<code class="code">IntK</code>.
<p>

<h3 id="3_Controllingthenamemapping">Controlling the name mapping</h3>
<p>

Ocamlnet-3.6.7 also introduces the name mapping directives for
enum constants:
<p>
<ul>
<li><code class="code">_lowercase</code>: the XDR name is lowercased</li>
<li><code class="code">_uppercase</code>: the XDR name is uppercased</li>
<li><code class="code">_capitalize</code>: the XDR name is capitalized</li>
<li><code class="code">_prefix "p"</code>: this prefix is prepended to the XDR name</li>
</ul>

For example, <code class="code">enum _lowercase _prefix "my_" { A=0, B=1 }</code>
would generate constants <code class="code">my_a</code> and <code class="code">my_b</code> (with the values
0 and 1, resp.).
<p>

<h2 id="2_XDRUnionsdiscriminatedbyintegers">XDR: Unions discriminated by integers</h2>
<p>

In XDR a union must always have disriminator. This can be an <code class="code">int</code>, an
<code class="code">unsigned int</code>, or an enumeration. The latter case is described in the
next section. In the integer case, the union declaration enumerates
a number of arms and a default arm:
<p>

<pre class="codepre"><code class="code"> union switch (d varname) {
     case Int0:
       t0 varname0;
     case Int1:
       t1 varname1;
     ...
     default:
       tD varnameD;
   }
</code></pre>
<p>

Here, <code class="code">d</code> is either <code class="code">int</code> or <code class="code">unsigned int</code>.
<p>

On term level, this is represented as <code class="code">Netxdr.XV_union_over_int(n,v)</code> for
the <code class="code">int</code> case or <code class="code">Netxdr.XV_union_over_uint(n,v)</code> for the <code class="code">unsigned int</code> case.
The number <code class="code">n</code> is the selected arm of the union (it is not indicated 
whether the arm is one of the declared arms or the default arm).
The value <code class="code">v</code> is the mapped value of the arm.
<p>

On the fully-mapped level, the union is mapped to a polymorphic
variant that corresponds to the original union declaration:
<p>

<pre class="codepre"><code class="code"> 
   [ `_Int0 of t0'
   | `_Int1 of t1'
   ...
   | `default of tD'
   ]
</code></pre>
<p>

The labels of the variants are derived from the <b>decimal literals</b> of
the numbers <code class="code">IntK</code> associated with the arms. For example, the
union 
<pre class="codepre"><code class="code"> union switch (int d) { 
     case -1: 
       hyper a;
     case 0:
       bool b;
     default:
       string s&lt;&gt;;
   }
</code></pre>
<p>

is mapped to
<p>

<pre class="codepre"><code class="code"> [ `__1 of int64 | `_0 of bool | `default of Netnumber.int4 * string ] </code></pre>
<p>

Note that the default case consists of the value of the discriminant
on the left and the value of the union on the right.
<p>

If an arm is simply <code class="code">void</code>, the corresponding variant will not have
an argument.
<p>

<h2 id="2_XDRUnionsdiscriminatedbyenumerations">XDR: Unions discriminated by enumerations</h2>
<p>

If the discriminator is an enumeration, different O'Caml types are used,
as a much nicer mapping is possible.
<p>

As for integer-discriminated unions, the arms are enumerated. The default
arm, however, is now optional. The whole construct looks like:
<p>

<pre class="codepre"><code class="code"> enum e {
     Name0 = Int0,
     Name1 = Int1,
     ...
   }

   union switch (e varname) {
     case Name0:
       t0 varname0;
     case Name1:
       t1 varname1;
     ...
     default:          /* optional! */
       tD varnameD;
   }
</code></pre>
<p>

On the term level, there are again two different ways of representing
a union value, namely by referring to the arm symbolically or by
position.
<p>

In the first case, the value is represented as
<code class="code">Netxdr.XV_union_over_enum(n,v)</code> where <code class="code">n</code> is the string name of the
value of the discriminator (i.e. <code class="code">"NameK"</code>), and <code class="code">v</code> is the mapped
value of the selected arm.
<p>

In the second case, the value is represented as
<code class="code">Netxdr.XV_union_over_enum_fast(K,v)</code> where <code class="code">K</code> is the position of
the value of the discriminator in the enumeration, and <code class="code">v</code> is the mapped
value of the selected arm.
<p>

On the fully-mapped level, the union is again mapped to a
polymorphic variant:
<p>

<pre class="codepre"><code class="code">  [ `Name0 of t0'
  | `Name1 of t1'
  | ...
  ]
</code></pre>
<p>

Every label of an enumerated value is turned into the label of the
variant. The argument is the mapped value of the corresponding arm.
Note that default values do not occur in this representation as
such.
<p>

For example, the union
<p>

<pre class="codepre"><code class="code"> enum e {
     CASEA = 5,
     CASEB = 42,
     CASEC = 7,
     CASED = 81
   }

  union switch (e d) {
    case CASEB:
      int b;
    case CASEC:
      void;
    default:
      hyper ad;
  }
</code></pre>
<p>

is mapped to the O'Caml type (the tags are all lowercase by default):
<p>

<pre class="codepre"><code class="code"> 
   [ 'casea of int64     (* expanded default case *)
   | `caseb of int32
   | `casec
   | `cased of int64     (* expanded default case *)
   ]
</code></pre>
<p>

If an arm is simply <code class="code">void</code> like for <code class="code">CASEC</code>, the corresponding variant will 
not have an argument like <code class="code">`casec</code>.
<p>

<h3 id="3_Controllingthenamemapping">Controlling the name mapping</h3>
<p>

Ocamlnet-3.6.7 also introduces the name mapping directives for
union tags:
<p>
<ul>
<li><code class="code">_lowercase</code>: the XDR name is lowercased</li>
<li><code class="code">_uppercase</code>: the XDR name is uppercased</li>
<li><code class="code">_capitalize</code>: the XDR name is capitalized</li>
<li><code class="code">_prefix "p"</code>: this prefix is prepended to the XDR name</li>
</ul>

An example: The XDR type
<p>

<pre class="codepre"><code class="code">  union _capitalize switch (e d) {
    case CASEB:
      int b;
    case CASEC:
      void;
    default:
      hyper ad;
  }
</code></pre>
<p>

is mapped to
<p>

<pre class="codepre"><code class="code"> 
   [ 'Casea of int64
   | `Caseb of int32
   | `Casec
   | `Cased of int64
   ]
</code></pre>
<p>

If there are name mapping directives in the definition of the enumeration
<code class="code">e</code>, these directives will be ignored. Only the directives in the <code class="code">union</code>
definition are used for generating the OCaml tag names.
<p>

<h2 id="2_RPCPrograms">RPC: Programs</h2>
<p>

In an .x file one can declare programs. A program consists of a number
of program versions, and every version consists of a number of
procedures. Every procedure takes a (possibly empty) list of arguments
and yields exactly one result (which may be <code class="code">void</code>, however). This
is written as:
<p>

<pre class="codepre"><code class="code">   /* type definitions come first */
   ...

   /* Now the programs: */
   program P1 {
       version V1 {
           r1 name1(arg11, arg12, ...) = L1;
           r2 name2(arg21, arg22, ...) = L2;
           ...
       } = M1;

       version V2 {
          ...
       } = M2;

       ...

   } = N1;

   program P2 {
     ...
   } = N2;

   ...
</code></pre>
<p>

Here, P1, P2, ..., V1, V2, ...,name1, name2, ...  are identifiers.
r1, r2, arg11, ... are type expressions. N1, N2, ..., M1, M2, ...,
L1, L2, ... are unsigned numbers.
<p>

Programs are dynamically represented using the <a href="Rpc_program.html"><code class="code">Rpc_program</code></a> module.
Every <a href="Rpc_program.html#TYPEt"><code class="code">Rpc_program.t</code></a> value contains the full signature of
exactly one version of one program.
<p>

In the generated type mapper module, the definitions for the programs
are available as constants <code class="code">program_</code><i>P</i><code class="code">'</code><i>V</i> where <i>P</i> is the name of
the program and <i>V</i> is the version of the program.
<p>

<h2 id="2_RPCClients">RPC: Clients</h2>
<p>

To write
<p>
<ul>
<li>Point to <a href="Rpc_client.html"><code class="code">Rpc_client</code></a> as basis</li>
<li>Clients can be used on term level by directly calling functions of
  <a href="Rpc_client.html"><code class="code">Rpc_client</code></a></li>
<li><code class="code">ocamlrpcgen</code> generates an enhanced client module containing
  procedure stubs. These stubs are on the fully-mapped level.</li>
</ul>

<h2 id="2_RPCServers">RPC: Servers</h2>
<p>

To write
<p>
<ul>
<li>Point to <a href="Rpc_server.html"><code class="code">Rpc_server</code></a> as basis</li>
<li>Servers can be created on term level by using functions
  of <a href="Rpc_server.html"><code class="code">Rpc_server</code></a></li>
<li><code class="code">ocamlrpcgen</code> generates an enhanced server module containing a
  converter to/from the fully-mapped level.
</li>
</ul>
<br>
</body></html>